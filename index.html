
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Polyglot</title>
  <meta name="author" content="Mark Fussell">

  
  <meta name="description" content="This is the fourth series describing the ADD: a radically more productive software development and delivery
environment. This series is on estimation &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://markfussell.emenar.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Polyglot" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Polyglot</a></h1>
  
    <h2>Build Valuable Systems, Better and Faster</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:markfussell.emenar.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/read-2/">READ: Scaled Agile</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-11-20T01:00:00-08:00" pubdate data-updated="true">Nov 20<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the fourth series describing the ADD: a radically more productive software development and delivery
environment.  This series is on estimation, and the first part is here: <a href="/blog/read-1">ADD: Estimation</a>.</p>

<h2>Scaled Agile</h2>

<p>As mentioned at the end of the first part, the extreme reaction to waterfall was to toss Analysis and Design
away, and go from very-loose requirements into actual implementation.  I believe this was a complete mistake
and has caused these &#8220;extreme&#8221; agile projects to be much <em>slower</em> and <em>unstable</em> compared to another approach.</p>

<p>The alternative is &#8220;Scaled Agile&#8221;, and by this I mean both:</p>

<ul>
<li>It is better designed for larger projects</li>
<li>It is achieved by scaling the activities of software development projects to be appropriate for the scale and needs of the project

<ul>
<li>Analysis &amp; Design efforts, deliverables, and precision can be smaller or larger</li>
<li>Increments of delivery can be smaller or larger</li>
<li>Allowance for iteration (repeating something to refine it) can be smaller or larger</li>
<li>Overlap of activities can be smaller or larger</li>
</ul>
</li>
</ul>


<p>The second item was tossed out with the &#8220;Waterfall&#8221;, at least by many in the industry.  A Waterfall is an extreme version of Agile (basically
no during-build agility), but going directly from verbal or spread-sheet based requirements is a similarly extreme version of Agile
and is unlikely to be as effective as properly-scaled versions of Agile.</p>

<h3>Retail Aspect / Evant / XP / Scaled Agile</h3>

<p>In 2003, while at Evant, we took an XP-based product (an advanced retail planning system) and worked on scaling the velocity and
agility of that project:</p>

<ul>
<li>To a bigger and non-XP team</li>
<li>Through multiple time-zones, including to India</li>
<li>Outside the development team into Product Management, Technical Sales, Marketing, and Support</li>
<li>Into a bigger portfolio of products that had inter-dependent deliverables</li>
<li>Across the portfolio to other product lines and teams</li>
</ul>


<p>Evant was eventually acquired and folded into a larger company, so much of the memory of what worked well and not about
this was lost.  Except the person who had the &#8216;APT&#8217; charter for Evant is still alive and cognizant.  And maybe a bit
opinionated, but will try to be object.</p>

<p>Ultimately, I think the scaling &#8220;worked in principle&#8221; but having a pure XP team shift to Scaled Agile is asking them
to give up an almost religious desire to &#8220;Not Analyze&#8221;, &#8220;Not Design&#8221;, and &#8220;Not be Objectively Measured!&#8221;.  If the
software developers really think they can program without being measured around productivity of delivering value to the
customer, you really have to let them go.  Maybe you have a wizard or two that makes crazy amazing things happen and you
don&#8217;t bother putting them into the normal project teams, but beyond that, you need to know if your products, projects,
and programs are <em>delivering a good ROI</em> and how you could make them deliver a better ROI.</p>

<p>To do that, you need to measure.  And returning to COSMIC, it is a way to measure the scale of software functionality.
Which isn&#8217;t the value to the customer of that system, but does reasonable express the complexity in providing the
value to the customer.</p>

<h3>COSMIC Analysis and Design</h3>

<p>The COSMIC process is clearly doing Analysis and Design, but in a relatively light and tunable way.  You can control:</p>

<ul>
<li>How much you decompose a system</li>
<li>The detail level and decomposition of the functional users of the system</li>
<li>How detailed you get with &#8220;Objects of Interest&#8221; and their corresponding &#8220;Data Groups&#8221;</li>
<li>What scope of the system you are going to measure</li>
<li>The granularity and formality of the functional user requirements (FURs)</li>
<li>Details around the non-FURs (indirect FURs, non-functional requirements, and other constraints)</li>
</ul>


<p>Doing the COSMIC measurement process is basically doing a minimal Analysis and Design on a system, so you have a good
basis for measuring its size and correlating that to development costs.  But it doesn&#8217;t just support the measurement,
it starts building a model of the user concepts (Object of Interests), their events, the system actions, and the
system components (based on the decomposition level).</p>

<h3>The Hub: Additional or Not Analysis and Design</h3>

<p>The COSMIC analysis can be a basis to additional investment in Analysis and Design, but that is optional.  That
is a choice of <em>delivery</em>.  You could have extreme delivery that ignored the COSMIC scope model completely.  Or
you could have extreme delivery that went into Waterfall after the COSMIC model was produced.  Or more sensibly,
you could start working <em>outward</em> from that hub:</p>

<ul>
<li>Does the minimal user concepts start describing a good logical data model?</li>
<li>Does the decomposition work with the implementation frameworks?  Should these be more fully designed or just implemented and noted how they are different.</li>
<li>If there is a lot of data-reading by different functional processes, are these from a single database or many or cached?</li>
</ul>


<p>Note that these &#8216;expansions&#8217; are not meant to alter the Hub: The measurement was done, and you can leave it alone
but leverage it for subsequent activities</p>

<h3>The Hub: Drilling down with COSMIC</h3>

<p>Alternatively, as you do analysis and design, you can produce a new granularity and scope that you want to now
measure again.  This could be done only when things seem to have become <em>very</em> different from original expectations,
or consistently to understand development &#8216;hidden requirements&#8217; or really &#8216;derived requirements&#8217; growth.  The
measurement should still ignore NFRs, but the deeper granularity and the conversion of some NFRs to FURs would
cause a different estimate of &#8216;Joints&#8217; because we have a different (more detailed) view of the system.</p>

<h3>Scaled Agile Manifesto</h3>

<p>I believe the Agile Manifesto was reactionary and extreme.  It had good ideas in it, but was missing core premises
that customers and development teams should expect from a good development project:</p>

<p>Manifesto:</p>

<ul>
<li>The Customer is always right about what they want.  The delivery team should always be honest and informative about what they can deliver and how they are doing it.

<ul>
<li>The Customer can change what they want, change the delivery team they use, but they can&#8217;t interfere within the delivery team</li>
<li>The delivery team should always deliver a functional-requirements-based estimate of a project independent of the technology and other delivery choices, so the customer knows what they are getting

<ul>
<li>Unless the customer clearly says &#8220;I don&#8217;t care&#8221;, in which case the delivery team can choose whether to do the work for their own internal benefit</li>
</ul>
</li>
</ul>
</li>
<li>Unless it helps a customer figure out what they want, requirement-fulfilling working systems are the only true progress of a project</li>
<li>A customer can desire to go forward to later stages (analysis, design, and implementation) before they are sure what they want

<ul>
<li>The cost of responding to change should be minimized while still supporting maximal ROI and velocity if there are no changes</li>
</ul>
</li>
<li>Processes and tools are to support the Customer and Ddelivery team&#8217;s needs, and not ends of themselves.

<ul>
<li>A default or customary usage of processes and tools is appropriate, but should be evaluated if there appears to be no need or even clear counter-benefit</li>
</ul>
</li>
</ul>


<p>Principles:</p>

<ul>
<li>Our highest priority is to satisfy our current customers

<ul>
<li>Through techniques that enable the customer to make good decisions, see verifiable progress toward their goals, and determine if they are getting a good ROI</li>
</ul>
</li>
<li>Our second highest priority is to satisfy future customers even better

<ul>
<li>Through evaluation of what went well and poorly, and looking for ways to give even higher satisfaction (whether ROI, predictability, or in other ways) to customers</li>
</ul>
</li>
<li>Both sides should care about each other:

<ul>
<li>A happy development team that cares about the customer is usually better at satisfying the customer</li>
<li>A customer that truly cares about the development team is usually better at inspiring the team to deliver its best</li>
</ul>
</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/read-1/">ADD: Estimation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-23T01:00:00-07:00" pubdate data-updated="true">Oct 23<span>rd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the fourth series describing the ADD: a radically more productive software development and delivery
environment.  The first series starts here: <a href="/blog/add-1/">Advanced Development and Delivery</a> and described the core four ingredients
of the ADD.  The second series starts here: <a href="/blog/addstack-1/">ADD Stack</a> and described the application stack and
system components associated with the ADD.  Some of these were Java / Grails specific, and some were more general
components and capabilities.  Together these went through a huge amount of functionality, flexibility, reliability,
and scalability.  Both for the IT infrastructure (whether on EC2 or on bare hardware) and for the applications
on top of that IT infrastructure. The third series starts here: <a href="/blog/add2-1">Advanced Development and Delivery Summary</a>
and gave an executive summary of the ADD.</p>

<p>This series is about project estimation, and is basically <em>orthogonal</em> to the ADD itself.  You can have good
 estimates or bad estimates.  The ADD delivers exceptional productivity.  How much you need to estimate is
 quite independent of productivity.  But by using Estimation and Feedback, you can figure out (a) whether
 to do a project and (b) whether the people you have are up-to-snuff.  If you <em>know</em> you have to do
 a project and you <em>have</em> certain people: don&#8217;t worry about the estimate.  It is irrelevant.  Just &#8220;wing it&#8221;.
 But if you have choices about either (a) whether to do a project or (b) what people to use or even (c)
 figuring out how good your team is after you do a project, then estimations are the core benchmark to
 give you feedback.</p>

<h2>Estimation is crazy-hard</h2>

<p>The problem with estimating is you can&#8217;t be good at it unless you have done something very similar before.  But
most workers in an industry are relatively new to it: less than ten years.  And if each project takes a couple
years to complete, you may have only a couple experiences in your first five years of work.  Change technologies,
change roles, or change organization, and your estimates are likely poorly based.</p>

<p>When something is too hard for someone to do easily, you need to decompose it to make it (a) easier and (b) separable.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/read-1/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/add2-1/">Advanced Development and Delivery (ADD) and the ADD Stack – Summary</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-23T01:00:00-07:00" pubdate data-updated="true">Oct 23<span>rd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the third series describing the ADD: a radically more productive development and delivery environment.  The
first series starts here: <a href="/blog/add-1/">Advanced Development and Delivery</a> and described the core four ingredients
 of the ADD.  The second series starts here: <a href="/blog/addstack-1/">ADD Stack</a> and described the application stack and
 system components associated with the ADD.  Some of these were Java / Grails specific, and some were more general
 components and capabilities.  Together these went through a huge amount of functionality, flexibility, reliability,
 and scalability.  Both for the IT infrastructure (whether on EC2 or on bare hardware) and for the applications
 on top of that IT infrastructure.</p>

<p>This series assumes you have at least skimmed the other two series, but this one is the summary of the other two.
It is an incremental growth of the architecture in a fairly macro sense, where the details are in the other series.</p>

<h2>The three ingredients</h2>

<p>Wait, it was four a moment ago.  The ADD requires four, but advanced project collaboration requires only three.  And
at the heart of the ADD is advanced project collaboration.  Collaboration has no &#8216;machines&#8217;, just people, so we put aside
one ingredient.  The remaining three are the <em>nucleus</em> of ADD:</p>

<ul>
<li>GitHub.com <a href="http://github.com/">http://github.com/</a></li>
<li>HipChat    <a href="http://HipChat.com/">http://HipChat.com/</a></li>
<li>Amazon S3  <a href="http://aws.amazon.com/">http://aws.amazon.com/</a></li>
</ul>


<p>These three ingredients can give individuals and teams 4x or more productivity.  And the reason is the same as for
 ADD.  There are two critical roles in any project:</p>

<ul>
<li>Changers</li>
<li>Watchers</li>
</ul>


<p>The Changers are gonna change, change, change, change and the Watchers are gonna watch, watch, watch, watch.  And
all of the people involve need to see what is going on (in the best way for them) and not be blocked getting things
done by others on the project.  They need perfect transparency.  Which will ultimately build incredible trust,
knowledge, and skill.</p>

<p>The three ingredients form the core of a three-way Venn diagram, that I will draw in hexagonal rings.</p>

<p><img src="/images/add2-1/add2_threeIngredients1.png" /></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/add2-1/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-10/">ADD Stack [Part-10]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-22T01:00:00-07:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.  The seventh went into logging, analytics, and monitoring of the running applications and nodes.
The eighth was an overview of Federation Components like caches, queues, payment services, and the like.  The ninth
was on a highly reliable, scalable, flexibly, and ultimately very simple worker model.</p>

<h2>WAR!</h2>

<p>Continuing with the worker model, we currently have a non-production Application Server running Grails:</p>

<ul>
<li><a href="http://fed1-app1.aws.gaps2c.com:8080">http://fed1-app1.aws.gaps2c.com:8080</a></li>
</ul>


<p>It is running grails &#8216;interactively&#8217; and &#8216;off-source&#8217;.  This is fast for deployment, but it is missing a few
things that people usually want in production:</p>

<ul>
<li>Well-defined artifact that has been tested and can&#8217;t &#8220;just change&#8221;</li>
<li>A container environment that can provide certain resources to the application (e.g. monitoring)</li>
<li>Removal of having to understand the &#8216;building&#8217; technology from the running technology (JVM)</li>
<li>That production has as few technologies as possible, and is normally missing &#8216;compilers&#8217; so people can&#8217;t tweak behavior</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-10/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-9/">ADD Stack [Part-9]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-21T01:00:00-07:00" pubdate data-updated="true">Oct 21<span>st</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.  The seventh went into logging, analytics, and monitoring of the running applications and nodes.
The eighth was an overview of Federation Components like caches, queues, payment services, and the like.</p>

<h2>Workers!</h2>

<p>Among the more interesting federation / deployment component are workers.  Workers are interesting because
they can do almost anything imaginable and they do it very efficiently.  How efficiently?  Well, the perfect
worker is at 100% when doing a task and <em>dead</em> when they have no tasks to do.  That is pretty darn efficient
because it approaches 100% and is only not 100% when we choose to not accept the &#8216;spin up&#8217; latency of getting
 a new worker.  As the amount of work increases, our pool of workers increase, and the spin-up-latency decreases
 on a per-chore basis.  That is <em>very cool</em>: as scale goes up, efficiency <em>increases</em>.  There are a lot of places that
 is not true for computers, so it is nice when it is.</p>

<h3>Work?  Chore?</h3>

<p>So we want to have a worker model where we can add a &#8216;chore&#8217; (a unit of work, using a term not otherwise used in
IT and CS&#8230; job, task, etc. are now ambivalent) to a queue of work-to-be-done, and have
 something do that chore.  There are a lot of ways to do this:</p>

<p> </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-9/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-8/">ADD Stack [Part-8]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-20T01:00:00-07:00" pubdate data-updated="true">Oct 20<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.  The seventh went into logging, analytics, and monitoring of the running applications and nodes.</p>

<h2>Federation Application Infrastructure</h2>

<p>The application stack we have so far:</p>

<ul>
<li> UI (both client and server)</li>
<li> Application Server (Grails, Java, potentially scripting engine)</li>
<li> Database (Maria or similar)</li>
</ul>


<p>Is very capable.  Using it combined with the ADD ingredients:</p>

<ul>
<li> GitHub – With resource, presence, application, and configuration information repositories</li>
<li> EC2 Instances – Running continuously or based on load, and running their &#8216;part&#8217; plus any dynamic configuration</li>
<li> S3 – For resources</li>
<li> HipChat – To let everyone know</li>
</ul>


<p>Makes for a very functional application.  The nodes and their applications can talk to each other based on presence.
The nodes and their application can keep certain data in-memory (cached).  The nodes can
 launch other nodes to handle load or do certain tasks.  An Application Server is a very generic thing and
 can do pretty much anything.</p>

<h3>Standard Federation Components</h3>

<p>Doing pretty much anything and everything turns out to be very confusing.  For people.  Big monoliths of capabilities
are basically beyond comprehension.  And the bigger the monolith, the harder it falls.  The more likely it falls.
And even if you have redundant monoliths, the system becomes very painful to maintain and to learn.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-8/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-7/">ADD Stack [Part-7]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-19T01:00:00-07:00" pubdate data-updated="true">Oct 19<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.</p>

<h2>Logging, Analytics, and Monitoring</h2>

<p>Returning to a bit more of an &#8216;IT&#8217; issue, how do we handle logging, monitoring, and analytics on our collection of
machines?  There are a number of choices:</p>

<ol>
<li>Run our own infrastructure</li>
<li>Go with an inexpensive provider</li>
<li>Go with a more capable provider</li>
<li>Don&#8217;t</li>
</ol>


<p>Of the above, I believe #3 is usually worth it until your scale gets to the point of needing #1.  Downgrading
from #3 to #2 is fine <em>after</em> you have learned the capabilities you are giving up.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-7/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-6/">ADD Stack [Part-6]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-17T01:00:00-07:00" pubdate data-updated="true">Oct 17<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting.</p>

<h2>Which UI framework?</h2>

<p>The <a href="/blog/addstack-4/">fourth article</a> discussed UI alternatives, but it was mostly about &#8216;architectural&#8217; alternatives
 and did not recommend a particular framework to use.  I believe that is the correct order: <em>how you use</em> the framework
 is usually more important than the framework itself.  People can correctly and improperly use all kinds of different technology.
Use a hammer correctly and you might have a slight penalty (rubber vs. metal), but
use it wrong (your thumb is targetable) and you can be seriously hurt.</p>

<p>There are a number of popular frameworks:</p>

<ul>
<li>Angular</li>
<li>Ember</li>
<li>Backbone</li>
<li>Sencha</li>
<li>etc.</li>
</ul>


<p>And deciding between them may seem like it should be done as &#8220;which has the best features?&#8221; but unless
one of them has a killer feature  that you care about
(Sencha can run the same code with both a desktop and mobile UI), and is worth its penalties (Sencha
is proprietary and very &#8216;different&#8217;) then &#8216;best features&#8217; is basically meaningless.  A better question is &#8220;Which
one do I understand the best?&#8221; and &#8220;Which one can other people on the team learn and share-code the best?&#8221;.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-6/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-5/">ADD Stack [Part-5]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-16T01:00:00-07:00" pubdate data-updated="true">Oct 16<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.</p>

<p>This article is about some fairly advanced capabilities, but capabilities that many projects find useful,
and so should be considered within the context of the overall context.  They are:</p>

<ul>
<li> Data Flexibility and Templating</li>
<li> Server Side Scripting</li>
</ul>


<h2>Data Flexibility and Template Systems</h2>

<p>One of the more interesting capability of an application is when users can control the content and presentation
of information.  Content is relatively easy given pure structured information is trivial to store in most
any database.  As the content becomes more unstructured you need to shift models and store it in a &#8216;meta&#8217;
structure like JSON.  As the content becomes bigger, you need the flexibility of very large objects (BLOBs and CLOBs)
stored either in the database or potentially within content repositories like S3.  Using the Annex model
discussed earlier, you can simply store a hash in the database and the actual content on S3, and then
<em>the client</em> can pull down the information without taxing your server network at all.</p>

<p>Having flexible data is not very useful unless you can present it.  If the data is in JSON, you need to
be able to take JSON and render it into text, HTML, or something the programming language can work with.
There are a number of template systems out there:</p>

<ul>
<li> Mustache</li>
<li> Jade</li>
<li> Dust</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-5/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-4/">ADD Stack [Part-4]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-15T03:00:00-07:00" pubdate data-updated="true">Oct 15<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third with the application stack (Grails and other technologies).</p>

<h2>User Interface</h2>

<p>Of all the technologies that change, the User Interface is by far the most diverse and most evolved.  Modern
databases are actually pretty old technology.  Modern languages are not significantly different from ancestors
in the 1970s.  Computers have the same main components.  Programmers interact with them with keyboards and screens.
If you picked well, you are programming better (tens of thousands of hours help) but are sadly
on pretty much the same core concepts you learned in your first five thousand hours.  Sigh.</p>

<p>Except.  Except the User Interface.  The implementation of user interfaces has grown since the 70s (the
first bit-mapped and mouse-based UIs were built way back then) through Smalltalk, Objective-C, Flash, Flex,
Angular, and other paths.  But even the devices have changed.  An iPhone is not a computer.  An Apple Watch
is not an iPhone.  Times they are a changing&#8230; at least for &#8216;devices&#8217;.</p>

<h3>It&#8217;s your face</h3>

<p>The User Interface is also the &#8216;face&#8217; of a company.  It sells the company.  Whether to new customers, existing
customers, employees, stock holders, or potential investors.  A web site like Rumble&#8217;s:</p>

<ul>
<li><a href="http://rumblegames.com/">http://rumblegames.com/</a></li>
</ul>


<p><img src="/images/addstack-4/addstack4_ui1.png" /></p>

<p>And Rumble&#8217;s actual games are trying to appeal to a particular audience (middle aged men) and give
them something they want (to feel powerful and sophisticated).</p>

<p>A web site like PortaPlanter:</p>

<ul>
<li><a href="http://PortaPlanter.com/">http://PortaPlanter.com/</a></li>
</ul>


<p><img src="/images/addstack-4/addstack4_ui2.png" /></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-4/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>About Me</h1>
  <p>
      <a href="http://www.linkedin.com/in/markfussell/">Linked In</a>
      &bull;
      <a href="http://github.com/markfussell/">Github</a>
      &bull;
      <a href="http://palobots.org/">PaloBots</a>
  </p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/read-2/">READ: Scaled Agile</a>
      </li>
    
      <li class="post">
        <a href="/blog/read-1/">ADD: Estimation</a>
      </li>
    
      <li class="post">
        <a href="/blog/add2-1/">Advanced Development and Delivery (ADD) and the ADD Stack – Summary</a>
      </li>
    
      <li class="post">
        <a href="/blog/addstack-10/">ADD Stack [Part-10]</a>
      </li>
    
      <li class="post">
        <a href="/blog/addstack-9/">ADD Stack [Part-9]</a>
      </li>
    
  </ul>
</section>
<section>
    <h1>Categories</h1>
    <span id="category-list"><a href='/blog/categories/add' style='font-size: 151.42857142857144%'>ADD</a> <a href='/blog/categories/agile' style='font-size: 102.14285714285714%'>Agile</a> <a href='/blog/categories/automation' style='font-size: 153.57142857142856%'>Automation</a> <a href='/blog/categories/cloud' style='font-size: 155.71428571428572%'>Cloud</a> <a href='/blog/categories/database' style='font-size: 104.28571428571429%'>Database</a> <a href='/blog/categories/dylan' style='font-size: 102.14285714285714%'>Dylan</a> <a href='/blog/categories/dynamic' style='font-size: 115.0%'>Dynamic</a> <a href='/blog/categories/ephemeral' style='font-size: 102.14285714285714%'>Ephemeral</a> <a href='/blog/categories/estimation' style='font-size: 102.14285714285714%'>Estimation</a> <a href='/blog/categories/flex' style='font-size: 115.0%'>Flex</a> <a href='/blog/categories/git' style='font-size: 160.0%'>Git</a> <a href='/blog/categories/grails' style='font-size: 125.71428571428572%'>Grails</a> <a href='/blog/categories/guideline' style='font-size: 102.14285714285714%'>Guideline</a> <a href='/blog/categories/it' style='font-size: 155.71428571428572%'>IT</a> <a href='/blog/categories/java' style='font-size: 110.71428571428571%'>Java</a> <a href='/blog/categories/ooad' style='font-size: 102.14285714285714%'>OOAD</a> <a href='/blog/categories/oopsla' style='font-size: 102.14285714285714%'>OOPSLA</a> <a href='/blog/categories/rails' style='font-size: 104.28571428571429%'>Rails</a> <a href='/blog/categories/relational' style='font-size: 104.28571428571429%'>Relational</a> <a href='/blog/categories/ruby' style='font-size: 132.14285714285714%'>Ruby</a> <a href='/blog/categories/rubyshoes' style='font-size: 108.57142857142857%'>RubyShoes</a> <a href='/blog/categories/scratch' style='font-size: 106.42857142857143%'>Scratch</a> <a href='/blog/categories/smalltalk' style='font-size: 136.42857142857144%'>Smalltalk</a> <a href='/blog/categories/stack' style='font-size: 125.71428571428572%'>Stack</a> <a href='/blog/categories/virtualization' style='font-size: 102.14285714285714%'>Virtualization</a> </span>
</section>
<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/markfussell">@markfussell</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'markfussell',
            count: 6,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Mark Fussell -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'markfussell';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
