
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Polyglot</title>
  <meta name="author" content="Mark Fussell">

  
  <meta name="description" content="This is a series describing various architectures I have worked with in the last two decades and some of their
benefits and issues. The table of &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://markfussell.emenar.com/blog/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Polyglot" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Polyglot</a></h1>
  
    <h2>Build Valuable Systems, Better and Faster</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:markfussell.emenar.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      

  
  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/arch-4/">Winster: Two Decades of Systems and Architectures</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-12-04T01:00:00-08:00" pubdate data-updated="true">Dec 4<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is a series describing various architectures I have worked with in the last two decades and some of their
benefits and issues.  The table of contents of the series is <a href="/blog/arch-1">here</a>.</p>

<p>Winster was a cooperative social gaming web site that enabled players to win real-world prizes.  It predated
Zynga and Facebook, but both of those companies &#8216;rose&#8217; during the time I worked for Winster.</p>

<h2>Major System Aspects</h2>

<p>Winster had a fairly standard Java backend that dealt with managing player information, talking with PayPal,
and keeping track of prizes, advertisements, and promotions.  This is pretty independent of what Winster was:
almost any commercial consumer site might have these capabilities.</p>

<p>What made Winster interesting is that the client was in Adobe Flash/Flex, it was realtime multi-player, and
the rules of the games were all stored on the server.  This created a pretty compelling environment for
players to interact: players could swap pieces and both be in better shape vs. &#8220;the house&#8221;.  And this interaction
supported a real-time chat system.  So very much like a card-game table without any competitiveness between players.</p>

<p>The client-server interaction was a combination of HTTP calls and socket-based bidirectional updates.</p>

<h2>AA-1 : No important logic on the client</h2>

<p>At Winster players could &#8216;win prizes&#8217; based on playing the games.  A lot of basic games out there put the actual
functionality into the game client (Flash, JavaScript, and even compiled desktop clients).  This is fine if there
is nothing at stake.  Someone hacks the client and they get to play a &#8216;different&#8217; game.  Many games even have
available &#8216;cheat modes&#8217; that make a different game easy to enable.</p>

<p>But if the client can actually impact the business, it has to be securely and correctly implementing business rules.
To enable this, you can try to make sure the client is an unhacked/unaltered version of the correct client.  Or more
simply, you can treat the client as untrusted: it makes request, and the server decides whether they are reasonable.</p>

<p>For Winster, we chose to not trust the client and so every action done on the client that affects the state of the
game went through a &#8216;game server&#8217; that knew the rules of the game.  There are a lot of wins for this:</p>

<ul>
<li>Servers tend to be easier to verify

<ul>
<li>You control the hardware completely, and at least at that time, there were significantly more testing frameworks</li>
</ul>
</li>
<li>Server failure is &#8216;unlikely&#8217; and should be totally visible if you have a problem</li>
<li>You are already writing the server in a particular language, so may more easily be able to augment its capabilities (although some clients have very nice game/event-oriented languages)</li>
</ul>


<p>There are some losses:</p>

<ul>
<li>Latency is guaranteed to be higher, and potentially has to be masked

<ul>
<li>For games like first-person shooters, you need to see the bullet fly even though the server determines the hit</li>
<li>For things like field-validation, you commonly have to repeat yourself on both the client and the server</li>
</ul>
</li>
<li>Clients sometimes have really nice game language</li>
<li>If there are delays in answers, you somehow have to get them to the client asynchronously</li>
<li>As clients scale &#8216;game servers&#8217; scale.</li>
</ul>


<p>The last loss can badly affect your operational profits, especially &#8216;pre-cloud&#8217; which is the timeframe that Winster
was.  We had to have servers big enough to deal with our peak loads and smart enough not to overload themselves.</p>

<p>The server-side game can be much simpler than the visual appearance on the client side (e.g. think the rules of chess
vs. a pretty chess board), but the server-side game has to protect the business rules of the game so people can&#8217;t game the game.</p>

<h2>AA-2 : Socket based client-server connection</h2>

<p>Winster existed before Websocket, Comet, and other specifications and approaches.  To communicate what other players
did within your room / table, the server sent updates through a direct socket.  Making sure customers could connect
with a straight socket was painful for customer support (if a customer was behind a very restrictive firewall) and
required augmentations to deal with &#8216;Flash Policies&#8217; and other aspects.  The advantage of the Game Server approach
was that the socket notifications were just that: notifications that the world was in a new state.  If clients missed
them, they could get updated on a subsequent notification.  Or catch up if initially stalled for some reason.</p>

<h2>AA-3 : Protocol versioning</h2>

<p>On top of the socket communication was a &#8216;V1&#8217; and &#8216;V2&#8217; version of a custom communication protocol.  A great rule to any protocol:</p>

<ul>
<li>Version it!</li>
</ul>


<p>You may not think it will change, but by simply versioning the protocol with a &#8216;V1&#8217; or &#8216;{ &#8220;version&#8221;:&#8221;v1&#8221;, &#8230;&#8217; or
similar you have enabled easily migrating forward with backward compatibility.  In many cases you can never be sure when or
if a client will be updated, so you need to enable continued support of old clients until they are commercially
non-viable.</p>

<h2>AA-4 : AJAX or Send-Data vs. rendering</h2>

<p>Because Flash/Flex is a very high-level UI language, the Java server had absolutely no ability to &#8216;render&#8217; for the client,
so there was a very strong client/UI vs. Server/Data &amp; Rules separation.  You make a request of the server and you get
data back via HTTP / XML or via the socket connection.  This enables the client to swap out and enables the server to
have easier automated testing.</p>

<h2>AA-5 : Logging and Telemetry</h2>

<p>Logging has a number of different purposes.  Three very different ones include:</p>

<ul>
<li>To see if the software has issues / defects</li>
<li>To have a record if a customer asks for &#8216;proof&#8217;</li>
<li>To see what a customer and the systems are doing compared to the business benefit</li>
</ul>


<p>Winster had a lot of logging and telemetry because it (a) needed to work, (b) needed to deal with grouchy customers,
and (c) needed to be very optimized to be profitable.</p>

<p>Logging frameworks and infrastructure improve every year, and it is important to put in the best structure you can
for the purposes you have.</p>
</div>
  
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/arch-3/">Velidom: Two Decades of Systems and Architectures</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-12-03T01:00:00-08:00" pubdate data-updated="true">Dec 3<span>rd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is a series describing various architectures I have worked with in the last two decades and some of their
benefits and issues.  The table of contents of the series is <a href="/blog/arch-1">here</a>.</p>

<p>Velidom came out of the technologies that helped increase velocity, agility, and scale of the Evant
development team.  This was in the mid 2000 time-frame and Evant had created technology which did
mass regression testing on every checkin, enabled continuous inter-team communication (including to India),
and various other major features.  Velidom was an attempt to productize this whole concept: The Velocity
to Dominate with an Advanced Software Development Factory.</p>

<h2>Major System Aspects</h2>

<p>The Velidom Factory was built primarily out of Java-based technologies and VMWare ESX capabilities.  The goal was
to integrate into common tools at the time (Eclipse / Subversion / etc.), automatically launch testing
and deployment servers on any given checkin, verify whether a commit was clean, and either push it through
to the main development line or roll it out based on that verification.</p>

<p>Another side of the factory was an agile development tool that tracked features, their values, the tasks
needed to complete them, and the status of everything.  This was for planning, agility, and measuring.  The
automation was to increase velocity and &#8216;reality&#8217; (if it didn&#8217;t successfully go in, it wasn&#8217;t in).</p>

<p>A final side of the factory was a set of communication tools for both real-time and knowledge accumulation,
where both of these were hooked into the other sides of the factory so what everything was visible and memorable.</p>

<p>If you look at the <a href="/blog/add-1">Advanced Development and Delivery Environment</a> you will see pretty much all of this
vision manifested through other companies&#8217; solutions.  Ultimately Velidom&#8217;s vision was too big to succeed with the
runway the startup had and the events that occurred during its&#8217; lifetime.</p>

<h2>AA-1 : Virtualization and Virtualized Desktops</h2>

<p>Of all the architectural aspects that Velidom got right, virtualizing the infrastructure was almost certainly
the biggest &#8216;Yes!&#8217;.  VMWare ESX was expensive, but having that infrastructure in place made it possible to
think about computation in a way very different from the raw hardware.  Ultimately from Amazon EC2 through to
Vagrant, this separation has come to pass as a higher-level-language of computational hardware.  Virtualized
computers can be built in minutes and discarded after being used.</p>

<p>Velidom provided virtualized desktops and servers as a service, and we spent the money and time
building out the hardware, the virtualized server side, and creating a custom desktop client.  The results were impressive,
leading edge, unreliable, and expensive.  Things were unreliable due to the client-server desktop communication
paradigm.  This needed good networks and a good protocol for the remote desktop.  And given these were development machines, they needed
to be secure, so each had its own private network.  Again, this was too big a vision to succeed at that time.  Focusing
on just servers may have been viable, but it wasn&#8217;t clear what the value was without a large base of customers committed
to good automated test suites (which is certainly plausible).</p>

<p>Expensive is relative, and the virtualization Velidom provided may have been viable except for an event that occurred
in 2006.  Amazon announced EC2, and suddenly the price point of virtualized computers dove to a number no one else
could compete with.  Even 10 years later, there are very few viable cloud providers, and no small ones.</p>

<h2>AA-2 : Tool Integration and Improvement</h2>

<p>One of the core Velidom concepts was the integration between tools (e.g. Eclipse) and the functionality we provided.
We had Eclipse plugins to do things within the factory, including chat, logging, automation, and other activities.
Integrating directly with a tool is nice, but definitely development expensive.  And the tools you are connecting with
(Eclipse and Subversion) may &#8216;go away&#8217;.  In 2005, Eclipse was a good choice, but if we had customers on a Microsoft
development stack, they might have been unsatisfiable.</p>

<p>The core problem wasn&#8217;t picking the right tool, it was picking any tool before having a Minimal Viable Product.  Tool
integration is not part of Minimal Viable: if your product is good at group chat, people will start using it.  A full
suite of products (the Factory) is also not part of Minimal Viable: whether chat or automated regression testing,
just get a product done and in the hands of customers to get feedback.  If they like your product, they will drive
integration with their favorite tools or your other products as an important improvement.</p>

<h2>AA-3 : Reactor</h2>

<p>The last architecture from Velidom that I am going to mention is the &#8216;reactor&#8217; or &#8216;queue&#8217; pattern.  Doing
a mass regression test with servers being created on the fly takes time.  Separating the &#8216;request&#8217; from the &#8216;task&#8217;
to complete the request is very effective for both scaling and also avoiding needless scaling.  If the automation
is fast enough, you don&#8217;t need to scale.  If you don&#8217;t have the extra money to buy the bonus performance,
you also don&#8217;t need to scale.  You can choose whether to pay for time or not.</p>

<p>The one aspect that for a codebase or similar &#8216;team progessive&#8217; activity is whether people wait for things to finish.
Ideally, you are &#8216;unblocked&#8217; while you wait: you can go on to something else.  But in a team environment, many people
are trying to get there work in the main codebase of work.  With Subversion, we had to do some annoyingly fancy tricks
to extract a bad build.  With Git and faster testing tools (in memory databases, better functional test declaration
languages), this is far less of a problem.</p>
</div>
  
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/arch-2/">Evant: Two Decades of Systems and Architectures</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-12-02T01:00:00-08:00" pubdate data-updated="true">Dec 2<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is a series describing various architectures I have worked with in the last two decades and some of their
benefits and issues.  The table of contents of the series is <a href="/blog/arch-1">here</a>.</p>

<p>Evant was originally named Retail Aspect and provided a Retail-as-a-service suite to companies that were
joining the Web retail boom (e.g. Disney Online).</p>

<h2>Major System Aspects</h2>

<p>The technical foundations of the company were from a
Java / Smalltalk background, so the server technologies were pretty mainstream Java enterprise technologies.
The client was the &#8216;leading edge&#8217; piece in the implementation technology, using a lot of JavaScript back in a very early time
for the language (early 2000s).  The whole system was notable in the number of automated regression tests
it contained (see below).  The database was initially Oracle but later moved to DB2.</p>

<p>Evant had a suite of products that did not succeed as a suite, potentially due to 9-11 causing a shutdown of online
retail activity.</p>

<h2>AA-1 (Architectural Aspect): Strong Client, Server-UI, and Server-Domain separation</h2>

<p>In terms of making the Evant Advanced Planning product capable, performant, and testable, there was a very strong
separation between &#8220;Interface&#8221; (UI or Test) and &#8220;Domain&#8221;.  The Domain includes all the business functionality within the planning
engine, exposed by a Java-based API.  It could be driven by either tests or the User Interface.  The API was identical,
so if the tests were successful, the engine was doing the &#8216;right thing&#8217;.  And the UI just needed to:</p>

<ul>
<li>Interact with the interface similarly to the tests

<ul>
<li>Or expand interface and tests for new needs</li>
</ul>
</li>
<li>Present the information pleasantly and effectively</li>
</ul>


<p>The UI could do all kinds of amazing things to transform the results or make actions easier for a user.  Since this was
a JavaScript application, lots of things could happen on the client without server interaction or asynchronously with
the server.  The important part was having a single contract that the two clients (one verifying, one using) could
run against.</p>

<h2>AA-2 : Mass Automated Testing</h2>

<p>The original Evant team was very committed to a full XP (Extreme Programming) approach and used TDD, Paired Programming,
and other aspects of XP as part of their development process.  I arrived after this development period, but there
were a fairly extensive collection of automated tests as part of the development artifacts.  However they were
created, they were incredibly useful for regression testing as we transformed the Domain to be far faster,
more scalable, and flexible.</p>

<p>Initially the tests were in XML to allow a very flexible system of automated testing that (in theory) could have tests
written by subject matter experts or general end users.  This flexibility made it a poor Domain-Specific-Language and
users could not write tests themselves.  The tests were also very repetitive (wet) given they had to describe
many states, inputs, and outputs within a matrix-like space.  Ultimately the solution was to move to a matrix-oriented
tool: a Spreadsheet.  And simply organize states, inputs, and outputs within that spreadsheet.  Automation turned
the spreadsheets into automated test specifications.  And the integration server ran this vast collection of tests
pretty much <em>all the time</em> to make sure nothing regressed (or at least it was identified if it did).</p>

<p>The automated testing was a continuous benefit as long as we could keep performance of the testing servers equal to
developer demands.</p>

<h2>AA-3 : Hidden Storage Model</h2>

<p>An important part of the Domain&#8217;s API was its&#8217; separation of &#8216;transactions&#8217; from its &#8216;storage&#8217;.  The system had
transactional statements (&#8216;update&#8217; and &#8216;save&#8217;) but how those things were accomplished was not visible at the
interface.  This separation prevented callers from caring and fiddling with how things were communicated to the
persistent storage.</p>

<p>Not all systems need this kind of separation: What is the chance you will swap out your database?  With a very different
database?  But the Evant storage model was a Hybrid-relational system with the bulk of the data stored in semi-opaque
compressed format.  So the domain acted transactionally, but under the covers it did a lot of data transformations to
organize and compress facts.  Transformations that evolved in time (different versions had better formats) and evolved
based on the size of the data space and performance tuning around it.</p>

<h2>AA-4 : Canned to Generic</h2>

<p>Another common and useful architectural progression is going from &#8216;canned&#8217; (fully specified) to &#8216;generic&#8217; (very flexible)
capabilities.  You should generally start at &#8216;canned&#8217; so you have super-control over what you are doing and what you
expect its results to be.  This is great for both modeling and testing the system.  As the canned capabilities grow,
they can become unwieldy and need to be more parameterized or even genericized (e.g. an Excel formula built out of
operations).</p>

<p>As you go from canned to generic, you will likely encounter both behavioral anomalies and performance anomalies.  But
if you start with generics that do the same as canned, you can focus on performance.  And then switch to generics that
are more broadly capable and focus on whether they behave correctly.  And then return to performance of these more
broadly capable generics.</p>

<h2>Next</h2>

<p><a href="/blog/arch-3">Velidom Factory</a></p>
</div>
  
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/arch-1/">Two Decades of Systems and Architectures</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-12-01T01:00:00-08:00" pubdate data-updated="true">Dec 1<span>st</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>It is now the end of 2015 and for decades I have been reading and writing software in both small and large companies, in startups and established enterprises, and in multiple industries.  My background includes several early languages (C, Basic, Pascal, Fortran, and specialty database systems), but I truly became a serious engineer in Smalltalk.  After doing several systems including IRIS-2 / <a href="http://cargosmart.com/">CargoSmart</a>, <a href="http://www.thefreelibrary.com/McKesson+and+SunScript+Sign+$500-Million+Pharmaceutical+Supply...-a020515184">BidLink</a>, and others, I switched to Java as my primary language.  Since then, I have also worked in Objective-C, Ruby/Rails, JavaScript (client and server), Python, and various other languages.</p>

<p>By building so many systems over the years, I have seen many choices and their impacts.  Sometimes the choice was before me, commonly it was mine and my team,  and sometimes people made choices after I &#8216;passed the system on&#8217;.  This series is meant to document as many of these systems as possible.  Previously I spoke at conferences and disseminated some of our insights.  I may return to that venue, but wanted to get more than a decade of work visible.</p>

<p>The systems, applications, and architectures documented here will eventually include:</p>

<ul>
<li><a href="/blog/arch-2">Evant Advanced Planning</a>: A multidimensional planning system

<ul>
<li>Java, JavaScript</li>
</ul>
</li>
<li><a href="/blog/arch-3">Velidom Factory</a>: A highly virtualized and automated software development environment / factory

<ul>
<li>Java, VmWare ESX, Subversion (as part of the infrastructure), Flash/Flex, and Eclipse plugins</li>
</ul>
</li>
<li><a href="/blog/arch-4">Winster</a>: A cooperative online gaming and social site

<ul>
<li>Java, Flash/Flex, MySQL</li>
</ul>
</li>
<li>FooPets: A virtual pet entertainment site

<ul>
<li>Ruby, Rails, Maya, iOS, etc.</li>
</ul>
</li>
<li>HeartPark: A 3-D world / game

<ul>
<li>Unity, Ruby, Rails</li>
</ul>
</li>
<li>Vive: A mobile health and wellness application

<ul>
<li>Grails, Java, YUI</li>
</ul>
</li>
<li>Epocrates EMR: An electronic medical records application

<ul>
<li>Ruby, Rails, iOS</li>
</ul>
</li>
<li>PeerCase: A mobile-first medical communication application

<ul>
<li>Grails, Sencha</li>
</ul>
</li>
<li>Rumble: A platform to support free-to-play and hiqh-quality games

<ul>
<li>Grails, Kafka, Redis, eJabberd, and a host of other technologies</li>
</ul>
</li>
<li>SnapArch: An architecture to build out a collection of services and applications on top of them

<ul>
<li>Spring, Angular, etc.</li>
</ul>
</li>
<li>ABC: An analytics platform for massive scale machine learning

<ul>
<li>Weka, Python, Grails, Amazon AWS services</li>
</ul>
</li>
<li>ADD: A recommended development &amp; delivery environment and platform for The Gap, Shaklee, and others</li>
<li>IRIS-2 / CargoSmart: An enterprise container-shipping logistics system

<ul>
<li>Smalltalk, GemStone, C++, Java, etc.</li>
</ul>
</li>
</ul>

</div>
  
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/read-2/">READ: Scaled Agile</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-11-20T01:00:00-08:00" pubdate data-updated="true">Nov 20<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the fourth series describing the ADD: a radically more productive software development and delivery
environment.  This series is on estimation, and the first part is here: <a href="/blog/read-1">ADD: Estimation</a>.</p>

<h2>Scaled Agile</h2>

<p>As mentioned at the end of the first part, the extreme reaction to waterfall was to toss Analysis and Design
away, and go from very-loose requirements into actual implementation.  I believe this was a complete mistake
and has caused these &#8220;extreme&#8221; agile projects to be much <em>slower</em> and <em>unstable</em> compared to another approach.</p>

<p>The alternative is &#8220;Scaled Agile&#8221;, and by this I mean both:</p>

<ul>
<li>It is better designed for larger projects</li>
<li>It is achieved by scaling the activities of software development projects to be appropriate for the scale and needs of the project

<ul>
<li>Analysis &amp; Design efforts, deliverables, and precision can be smaller or larger</li>
<li>Increments of delivery can be smaller or larger</li>
<li>Allowance for iteration (repeating something to refine it) can be smaller or larger</li>
<li>Overlap of activities can be smaller or larger</li>
</ul>
</li>
</ul>


<p>The second item was tossed out with the &#8220;Waterfall&#8221;, at least by many in the industry.  A Waterfall is an extreme version of Agile (basically
no during-build agility), but going directly from verbal or spread-sheet based requirements is a similarly extreme version of Agile
and is unlikely to be as effective as properly-scaled versions of Agile.</p>

<h3>Retail Aspect / Evant / XP / Scaled Agile</h3>

<p>In 2003, while at Evant, we took an XP-based product (an advanced retail planning system) and worked on scaling the velocity and
agility of that project:</p>

<ul>
<li>To a bigger and non-XP team</li>
<li>Through multiple time-zones, including to India</li>
<li>Outside the development team into Product Management, Technical Sales, Marketing, and Support</li>
<li>Into a bigger portfolio of products that had inter-dependent deliverables</li>
<li>Across the portfolio to other product lines and teams</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/read-2/">Read on &rarr;</a>
    </footer>
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/read-1/">ADD: Estimation</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-23T01:00:00-07:00" pubdate data-updated="true">Oct 23<span>rd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the fourth series describing the ADD: a radically more productive software development and delivery
environment.  The first series starts here: <a href="/blog/add-1/">Advanced Development and Delivery</a> and described the core four ingredients
of the ADD.  The second series starts here: <a href="/blog/addstack-1/">ADD Stack</a> and described the application stack and
system components associated with the ADD.  Some of these were Java / Grails specific, and some were more general
components and capabilities.  Together these went through a huge amount of functionality, flexibility, reliability,
and scalability.  Both for the IT infrastructure (whether on EC2 or on bare hardware) and for the applications
on top of that IT infrastructure. The third series starts here: <a href="/blog/add2-1">Advanced Development and Delivery Summary</a>
and gave an executive summary of the ADD.</p>

<p>This series is about project estimation, and is basically <em>orthogonal</em> to the ADD itself.  You can have good
 estimates or bad estimates.  The ADD delivers exceptional productivity.  How much you need to estimate is
 quite independent of productivity.  But by using Estimation and Feedback, you can figure out (a) whether
 to do a project and (b) whether the people you have are up-to-snuff.  If you <em>know</em> you have to do
 a project and you <em>have</em> certain people: don&#8217;t worry about the estimate.  It is irrelevant.  Just &#8220;wing it&#8221;.
 But if you have choices about either (a) whether to do a project or (b) what people to use or even (c)
 figuring out how good your team is after you do a project, then estimations are the core benchmark to
 give you feedback.</p>

<h2>Estimation is crazy-hard</h2>

<p>The problem with estimating is you can&#8217;t be good at it unless you have done something very similar before.  But
most workers in an industry are relatively new to it: less than ten years.  And if each project takes a couple
years to complete, you may have only a couple experiences in your first five years of work.  Change technologies,
change roles, or change organization, and your estimates are likely poorly based.</p>

<p>When something is too hard for someone to do easily, you need to decompose it to make it (a) easier and (b) separable.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/read-1/">Read on &rarr;</a>
    </footer>
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/add2-1/">Advanced Development and Delivery (ADD) and the ADD Stack – Summary</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-23T01:00:00-07:00" pubdate data-updated="true">Oct 23<span>rd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the third series describing the ADD: a radically more productive development and delivery environment.  The
first series starts here: <a href="/blog/add-1/">Advanced Development and Delivery</a> and described the core four ingredients
 of the ADD.  The second series starts here: <a href="/blog/addstack-1/">ADD Stack</a> and described the application stack and
 system components associated with the ADD.  Some of these were Java / Grails specific, and some were more general
 components and capabilities.  Together these went through a huge amount of functionality, flexibility, reliability,
 and scalability.  Both for the IT infrastructure (whether on EC2 or on bare hardware) and for the applications
 on top of that IT infrastructure.</p>

<p>This series assumes you have at least skimmed the other two series, but this one is the summary of the other two.
It is an incremental growth of the architecture in a fairly macro sense, where the details are in the other series.</p>

<h2>The three ingredients</h2>

<p>Wait, it was four a moment ago.  The ADD requires four, but advanced project collaboration requires only three.  And
at the heart of the ADD is advanced project collaboration.  Collaboration has no &#8216;machines&#8217;, just people, so we put aside
one ingredient.  The remaining three are the <em>nucleus</em> of ADD:</p>

<ul>
<li>GitHub.com <a href="http://github.com/">http://github.com/</a></li>
<li>HipChat    <a href="http://HipChat.com/">http://HipChat.com/</a></li>
<li>Amazon S3  <a href="http://aws.amazon.com/">http://aws.amazon.com/</a></li>
</ul>


<p>These three ingredients can give individuals and teams 4x or more productivity.  And the reason is the same as for
 ADD.  There are two critical roles in any project:</p>

<ul>
<li>Changers</li>
<li>Watchers</li>
</ul>


<p>The Changers are gonna change, change, change, change and the Watchers are gonna watch, watch, watch, watch.  And
all of the people involve need to see what is going on (in the best way for them) and not be blocked getting things
done by others on the project.  They need perfect transparency.  Which will ultimately build incredible trust,
knowledge, and skill.</p>

<p>The three ingredients form the core of a three-way Venn diagram, that I will draw in hexagonal rings.</p>

<p><img src="/images/add2-1/add2_threeIngredients1.png" /></p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/add2-1/">Read on &rarr;</a>
    </footer>
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-10/">ADD Stack [Part-10]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-22T01:00:00-07:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.  The seventh went into logging, analytics, and monitoring of the running applications and nodes.
The eighth was an overview of Federation Components like caches, queues, payment services, and the like.  The ninth
was on a highly reliable, scalable, flexibly, and ultimately very simple worker model.</p>

<h2>WAR!</h2>

<p>Continuing with the worker model, we currently have a non-production Application Server running Grails:</p>

<ul>
<li><a href="http://fed1-app1.aws.gaps2c.com:8080">http://fed1-app1.aws.gaps2c.com:8080</a></li>
</ul>


<p>It is running grails &#8216;interactively&#8217; and &#8216;off-source&#8217;.  This is fast for deployment, but it is missing a few
things that people usually want in production:</p>

<ul>
<li>Well-defined artifact that has been tested and can&#8217;t &#8220;just change&#8221;</li>
<li>A container environment that can provide certain resources to the application (e.g. monitoring)</li>
<li>Removal of having to understand the &#8216;building&#8217; technology from the running technology (JVM)</li>
<li>That production has as few technologies as possible, and is normally missing &#8216;compilers&#8217; so people can&#8217;t tweak behavior</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-10/">Read on &rarr;</a>
    </footer>
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-9/">ADD Stack [Part-9]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-21T01:00:00-07:00" pubdate data-updated="true">Oct 21<span>st</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.  The seventh went into logging, analytics, and monitoring of the running applications and nodes.
The eighth was an overview of Federation Components like caches, queues, payment services, and the like.</p>

<h2>Workers!</h2>

<p>Among the more interesting federation / deployment component are workers.  Workers are interesting because
they can do almost anything imaginable and they do it very efficiently.  How efficiently?  Well, the perfect
worker is at 100% when doing a task and <em>dead</em> when they have no tasks to do.  That is pretty darn efficient
because it approaches 100% and is only not 100% when we choose to not accept the &#8216;spin up&#8217; latency of getting
 a new worker.  As the amount of work increases, our pool of workers increase, and the spin-up-latency decreases
 on a per-chore basis.  That is <em>very cool</em>: as scale goes up, efficiency <em>increases</em>.  There are a lot of places that
 is not true for computers, so it is nice when it is.</p>

<h3>Work?  Chore?</h3>

<p>So we want to have a worker model where we can add a &#8216;chore&#8217; (a unit of work, using a term not otherwise used in
IT and CS&#8230; job, task, etc. are now ambivalent) to a queue of work-to-be-done, and have
 something do that chore.  There are a lot of ways to do this:</p>

<p> </div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-9/">Read on &rarr;</a>
    </footer>
  


  </article>
  <hr>

  
  <article class="listing">
    
  <header>
    
      <h1 class="entry-title"><a href="/blog/addstack-8/">ADD Stack [Part-8]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-10-20T01:00:00-07:00" pubdate data-updated="true">Oct 20<span>th</span>, 2015</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with &#8216;Testing&#8217;.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.  The seventh went into logging, analytics, and monitoring of the running applications and nodes.</p>

<h2>Federation Application Infrastructure</h2>

<p>The application stack we have so far:</p>

<ul>
<li> UI (both client and server)</li>
<li> Application Server (Grails, Java, potentially scripting engine)</li>
<li> Database (Maria or similar)</li>
</ul>


<p>Is very capable.  Using it combined with the ADD ingredients:</p>

<ul>
<li> GitHub – With resource, presence, application, and configuration information repositories</li>
<li> EC2 Instances – Running continuously or based on load, and running their &#8216;part&#8217; plus any dynamic configuration</li>
<li> S3 – For resources</li>
<li> HipChat – To let everyone know</li>
</ul>


<p>Makes for a very functional application.  The nodes and their applications can talk to each other based on presence.
The nodes and their application can keep certain data in-memory (cached).  The nodes can
 launch other nodes to handle load or do certain tasks.  An Application Server is a very generic thing and
 can do pretty much anything.</p>

<h3>Standard Federation Components</h3>

<p>Doing pretty much anything and everything turns out to be very confusing.  For people.  Big monoliths of capabilities
are basically beyond comprehension.  And the bigger the monolith, the harder it falls.  The more likely it falls.
And even if you have redundant monoliths, the system becomes very painful to maintain and to learn.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/addstack-8/">Read on &rarr;</a>
    </footer>
  


  </article>
  <hr>


  <div class="pagination">
    
      <a class="btn pull-left" href="/blog/page/2/">&larr; Older</a>
    

    
  </div>
    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Mark Fussell -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'markfussell';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
