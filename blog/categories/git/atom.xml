<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | Polyglot]]></title>
  <link href="http://markfussell.emenar.com/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://markfussell.emenar.com/"/>
  <updated>2015-10-01T13:19:21-07:00</updated>
  <id>http://markfussell.emenar.com/</id>
  <author>
    <name><![CDATA[Mark Fussell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Development and Delivery (ADD) [Part-3]]]></title>
    <link href="http://markfussell.emenar.com/blog/add-3/"/>
    <updated>2015-10-01T02:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/add-3</id>
    <content type="html"><![CDATA[<p>This is the third installment of describing a radically more productive development and delivery environment.</p>

<p>The first part is here: <a href="/blog/add-1/">Intro</a>.  In the previous parts I described the big picture and the
first part of the Vagrant bootstrap.</p>

<h2>EC2</h2>

<p>The Vagrant bootstrap occurred through 'bash' files that shaped (put shape information into files) and
the 'init' itself to get access to the repo (repo2) that contains the true configuration.  For EC2
the same thing happens within a CloudFormation template.  The code of the 'init' is almost identical, but because
it is in a JSON file there is a lot of noise as the string gets concatenated together.</p>

<!-- more -->


<h3>Shaping</h3>

<p>```json</p>

<pre><code>"TemplateConstant" : {
  "stacktype" : { "value" : "ControlServer1" },
  "initgitrepo" : { "value" : "repo2_petulant-cyril" },
  "nodepart" : { "value" : "controlnode" }
},
</code></pre>

<p>```</p>

<p>```json</p>

<pre><code>        "files" : {
          "/root/nodeinfo/stacktype.txt" : {
            "content" : { "Fn::Join" : ["", [
              { "Fn::FindInMap" : [ "TemplateConstant", "stacktype", "value" ] },
              ""
            ]]},
            "mode"  : "000700",
            "owner" : "root",
            "group" : "root"
          },
          "/root/nodeinfo/initgitrepo.txt" : {
            "content" : { "Fn::Join" : ["", [
              { "Fn::FindInMap" : [ "TemplateConstant", "initgitrepo", "value" ] },
              ""
            ]]},
            "mode"  : "000700",
            "owner" : "root",
            "group" : "root"
          },
</code></pre>

<p>```</p>

<h3>Init</h3>

<p>```json</p>

<pre><code>    "UserData"       : { "Fn::Base64" : { "Fn::Join" : ["", [
      "#!/bin/bash -v\n",
      "yum update -y aws-cfn-bootstrap\n",

      "# Helper function\n",
      "function error_exit\n",
      "{\n",
      "  /opt/aws/bin/cfn-signal -e 1 -r \"$1\" '", { "Ref" : "WaitHandle" }, "'\n",
      "  exit 1\n",
      "}\n",

      "# Install LAMP packages\n",
      "/opt/aws/bin/cfn-init -s ", { "Ref" : "AWS::StackName" }, " -r PrimaryLaunchConfig ",
      "    --access-key ",  { "Ref" : "HostKeys" },
      "    --secret-key ", {"Fn::GetAtt": ["HostKeys", "SecretAccessKey"]},
      "    --region ", { "Ref" : "AWS::Region" }, " || error_exit 'Failed to run cfn-init'\n",

      "yum -y install git \n",

      "echo 'Fetch s3cmd to get credentials' \n",
      "mkdir /root/download/ \n",
      "pushd /root/download/ \n",
      "git clone git://github.com/s3tools/s3cmd.git \n",
</code></pre>

<p>```</p>

<h3>Launching and Clusters</h3>

<p>A CloudFormation can provision a single server, but it is used more for clusters.  Instead of creating a server, we create
a server definition and then say how many servers we want.  The 'PrimaryServerGroup' defines this:</p>

<p>```json</p>

<pre><code>"PrimaryServerGroup" : {
  "Type" : "AWS::AutoScaling::AutoScalingGroup",
  "Properties" : {
    "Tags": [
      { "Key": "add:stacktype", "Value": { "Fn::FindInMap" : [ "TemplateConstant", "stacktype", "value" ] }, "PropagateAtLaunch" : "true" },
      { "Key": "add:nodepart", "Value": { "Fn::FindInMap" : [ "TemplateConstant", "nodepart", "value" ] }, "PropagateAtLaunch" : "true" }
    ],
    "AvailabilityZones" : { "Fn::GetAZs" : "" },
    "LaunchConfigurationName" : { "Ref" : "PrimaryLaunchConfig" },
    "MinSize" : "1",
    "MaxSize" : "1",
    "DesiredCapacity" : "1"
  }
},
</code></pre>

<p>```</p>

<p>Note that it ends with '1', '1', '1' meaning this is just a single server.  But those numbers can be changed at any time.</p>

<p>Given the DesiredCapacity is '1', if you ever kill a server, a new one will be spun up.</p>

<h3>EC2 Keypairs</h3>

<p>Another difference of the EC2 model is that EC2 holds onto the keypair that is used for logging into it.  So that information
doesn't need to be exposed.  And further, the EC2 version creates a special 'IAM' agent for the machine.</p>

<h3>EC2 Dashboard</h3>

<p><img src="http://markfussell.emenar.com/images/add-3/add3_ec2_cv1.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Development and Delivery (ADD) [Part-2]]]></title>
    <link href="http://markfussell.emenar.com/blog/add-2/"/>
    <updated>2015-10-01T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/add-2</id>
    <content type="html"><![CDATA[<p>This is the second installment of describing a radically more productive development and delivery environment.</p>

<p>The first part is here: <a href="/blog/add-1/">Intro</a>, but to summarize: since the 1970s, the most productive way
to develop and deliver software was present in Smalltalk, Lisp, and other languages (Mesa/Cedar at Xerox)
by using a very simple and powerful model.  You take a computer with a fully running environment, you tweak it,
and then you clone that.  This way you: (a) minimize what could go wrong, and (b) maximize what will continue to work.
It is very tangible and very instructive (you have full source for everything that is running).  You tweak other
people's masterpieces until they do what you want, and you learn from their masterpieces to create your own.</p>

<h2>ADD: How Better?</h2>

<p>As described before, ADD has four ingredients:</p>

<ul>
<li>Amazon EC2 <a href="http://aws.amazon.com/">http://aws.amazon.com/</a></li>
<li>Amazon S3  <a href="http://aws.amazon.com/">http://aws.amazon.com/</a></li>
<li>GitHub.com <a href="http://github.com/">http://github.com/</a></li>
<li>HipChat    <a href="http://HipChat.com/">http://HipChat.com/</a></li>
</ul>


<p>And these are hooked together to enable 'Changers', 'Watchders', and 'Machines' to be super-productive.  How
is the ADD <em>more productive</em> than the tweak and clone model?  It is because it solves the core problems
of the clone model:</p>

<ul>
<li>How do we clone to <em>different</em> environments?  Different hardware or configuration changes?</li>
<li>How do we reduce the amount of information we have to clone?</li>
<li>How do we reduce the time it takes to transport the clone?</li>
<li>How do we know what version of the clone is on any machine?</li>
<li>How do we create thousands of clones?</li>
<li>How do we know what is different about the different clones?</li>
<li>...</li>
</ul>


<!-- more -->


<p>The first three ingredients are the most powerful and enables a fantastic improvement to the tweak and clone model.
The last ingredient is mainly for people to be able to enjoy the ADD more easily.  It is like the 'salt-to-taste'
and how much you integrate HipChat in with the rest of the ecosystem is up to your team.  But the more it is integrated,
the more your team will know what is going on, the more easily your team will solve problems/issues, and the more easily
you will onboard new people.</p>

<h2>ADD: GitHub</h2>

<p>GitHub will become your primary resource for <em>everything</em> related to 'information'.  Human notes... go into GitHub
in Markdown format (like this blog).  Meeting notes.  GitHub.  Images to go with Meeting notes.  GitHub.  Your first,
most important, repository will be called 'repo1' and will be all the notes you want the team to see.  No more
arguing about the best Wiki, blogger, file store, etc.  The answer will always be the same.  It is in GitHub.  Because
<em>everything</em> is in GitHub.</p>

<p>Why?  Because it is simple.  It is accessible.  It is powerful.  Keeps history.  Takes almost no space.
It works offline (on an airplane).  And it works with multiple writers.  And if GitHub dies...
you have a complete copy of everything you need to bring up your own 'Git'.  Asking 'Why?' is silly.  First
move to GitHub for all of this, and then ask 'Why?' to everything else.</p>

<h2>ADD: S3 : Annexed Repositories</h2>

<p>Git and GitHub are not good with large binary assets.  They get stored in a notably raw way and just make the
repository huge for no benefit.  So don't store large binary assets in GitHub.  Instead store a reference to
the binary object up in S3.  Retrieve it as needed.  See <a href="/blog/git-about-everything-annex">Annex</a></p>

<h2>ADD: EC2 and Vagrant and GitHub and S3</h2>

<p>Using EC2 and Vagrant with a 'PushMe-PullYou' model (see <a href="/blog/git-about-everything-it-automation-2">PushMePullYou</a>)
solves a host of development, delivery, and operations issues.  The benefits are:</p>

<ul>
<li>Complete version control of machines â€“ both operations and developers' machines (or part of a developers' machines)</li>
<li>A very simple model that enables machines to be provisioned rapidly and to change their state every minute (if needed)</li>
<li>An impressive fan-out of activity</li>
<li>An ability to work offline (say GitHub goes down) or to have complete redundancy (use both GitHub and BitBucket to avoid SPOF)</li>
<li>Inherently no SPOF</li>
<li>Dependent on <em>nothing</em> - Not EC2, Not Vagrant, not GitHub, not S3.  These may be gold standards, but they can all be swapped out</li>
</ul>


<p>This is where the ADD just shoots through the roof.  The ADD uses particular technology to show "How it is done" and
get you doing it right.  But it is not dependent on those technologies.  No Chef.  Unless you want it (and I recommend 'Solo').
No Linux unless you want it.  No Grails or Groovy unless you want it.  Use Google Compute if you want to.  Or even your
own Big Iron.  The ADD is a set of tools and methods that work well together and is most easily seen with the Gold Standard.
But it is beyond them: like a mathematical formula (the Golden Ratio) that can be present in many forms.</p>

<h2>Demo or Die!</h2>

<p>The core demo for this article will walk through bringing up a server on EC2 <em>and</em> Vagrant.  If you are not familiar
with EC2 and Vagrant, please read some of my other articles or meeting notes, or look to the web for resources.</p>

<h3>Vagrant</h3>

<p>The demo in Vagrant is slightly simpler than in EC2 because you are dealing with a machine at a time.  On EC2 you
should be thinking 'Clusters' of machines that work together in 'Federations', and the technology to do that is
more complicated and more EC2-centric.</p>

<p>In Vagrant, you have a 'Box' definition and then an actual virtual instance.  To provision an instance you have
to 'init' it, bring it up, and then configure it.  Except you don't.  As long as the instance knows how to
bootstrap itself.  Demo:</p>

<h4>Vagrantfile</h4>

<p>```ruby
  config.vm.provision "shell", inline: &lt;&lt;-SHELL</p>

<pre><code> su root
 source /vagrant/resource/centos7a_cf2_ControlServer1.sh
 source /vagrant/resource/centos7a_cred_bot1.sh
 source /vagrant/resource/centos7a_boot1.sh
</code></pre>

<p>  SHELL
```</p>

<p>As the last step of the Vagrantfile, the (linux) server does three things:</p>

<ul>
<li>It 'shapes' itself to be a ControlServer</li>
<li>It 'shapes' itself to be 'bot1' for it's credentials</li>
<li>It configures itself with a boot script</li>
</ul>


<p>By the end of the boot script it will be fully alive and running.  Watching for changes to repositories that
indicate it should do something.  You should never have to SSH into the machine... ever.  You can to look around
(like the Magic Schoolbus) but you should treat it like it is a living creature and <em>never</em> touch anything inside
it.  If you have to touch something, fix the 'DNA' (that boot script), kill the server, and launch a new one.</p>

<p>Given this is a Vagrant file on the developer's machine, they can certainly feel free to fiddle with things.  But that is
to learn to <em>understand</em> the server.  Some EC2 servers may even be for 'fiddling'.  But QA and production servers should
never be touched and should only be looked at if they are confusing people (who already understand the fiddling and Vagrant servers).</p>

<p>Both 'ControlServer1.sh' and 'cred_bot1.sh' simply put information into files under '/root/nodeinfo/'.  This is an
amazingly flexible approach that works very simply for Vagrant and EC2.</p>

<h4>ControlServer1.sh</h4>

<p>```bash</p>

<h1>!/bin/bash -v</h1>

<p>export stacktype="ControlServer1"
export initgitrepo="repo2_petulant-cyril"
export nodepart="controlnode"</p>

<p>mkdir /root/nodeinfo
echo $stacktype > /root/nodeinfo/stacktype.txt
echo $initgitrepo > /root/nodeinfo/initgitrepo.txt
echo $nodepart > /root/nodeinfo/nodepart.txt
```</p>

<h4>cred_bot1.sh</h4>

<p>The actual version of this would contain real credential information.  The actual version would be developer-specific and not in version control.</p>

<p>```bash</p>

<h1>!/bin/bash -v</h1>

<p>export access_key="access_key"
export secret_key="secret_key"
export keyname="keyname"</p>

<p>echo $access_key > /root/nodeinfo/access_key.txt
echo $secret_key > /root/nodeinfo/secret_key.txt
echo $keyname > /root/nodeinfo/keyname.txt</p>

<p>cat >> /root/.s3cfg &lt;&lt;EOS
[default]
access_key = $access_key
secret_key = $secret_key</p>

<p>EOS
```</p>

<h4>centos7a_boot1.sh</h4>

<p>This script mirrors most of how EC2 works: we need this machine to be able to checkout a repository from GitHub but
we only have Amazon credentials.  So we put the full credentials into S3 and check them out.  Then we can clone
the 'repo2' provisioning repo and go from there.</p>

<p>```bash</p>

<h1>!/bin/bash -v</h1>

<p>yum -y install git</p>

<p>echo 'Fetch s3cmd to get credentials'
mkdir /root/download/
pushd /root/download/
git clone git://github.com/s3tools/s3cmd.git
cd s3cmd
git checkout a91c40fcd14772fa48297e676c8c6efa1aabc3c0
python --version
python setup.py install
mkdir /root/bin/
mv /root/download/s3cmd /root/bin/s3cmd
popd</p>

<p>echo 'Retrieve SSH keys for Github'
pushd /root/.ssh
/root/bin/s3cmd/s3cmd --config /root/.s3cfg get s3://gapshaklee/it/key/shakbot1key2/<em>
chmod 600 id</em>
cd /root
ssh -v -o StrictHostKeyChecking=no -T git@github.com</p>

<p>mkdir /root/gitrepo
cd /root/gitrepo
git clone git@github.com:shaklee/<code>cat /root/nodeinfo/initgitrepo.txt</code>.git</p>

<p>cd /root/gitrepo/<code>cat /root/nodeinfo/initgitrepo.txt</code>
include () { if [[ -f \"$1\" ]]; then source \"$1\"; else echo \"Skipped missing: $1\"; fi }
include it/nodeinit/common/init.sh</p>

<h1>Zzzzz....</h1>

<p>```</p>

<h4>Directory Layout</h4>

<p>An image of the directory structure is below.  The little-meaning but organized name 'repo2' is augmented with a human suffix 'petulant-cyril'
to make it unique and memorable. 'repo2' is always the first operations repo and 'repo3' is always the first development repo.
The suffix is generated by GitHub or other name generators.</p>

<p>The layout of the directory contains a few things:</p>

<ul>
<li> A 'bin' that contains scripts that can be run within this repository.  The 'deflateAll.sh' script is important enough to be put in the root, but the rest are inside 'bin'.</li>
<li> All things other than the README and deflatAll should be in consistent subdirectories.  The 's3info' is for the annex.  And 'it' is for everything related to being it.  'src' and 'test' are meaningless at the root level and should not be checked in.</li>
<li> You can see the 'node' folders.  A 'node' is a virtual server (Chef and others terminology).  'nodeaws' is for aws related node configuration.  'nodeinit' is common.  'nodevag' is for vagrant.  'resource' contains resourceds in general if under 'it' and for something more specific if lower</li>
<li> folder names are never capitalized or pluralized to avoid inter-operating-system issues.  File names can be any format, but I use augmented CamelCase (with snakes) or snake_case depending on the situation.</li>
<li> You can see the annexed files in the '/it/resource' folder.  They are all '50 bytes'</li>
</ul>


<p><img src="http://markfussell.emenar.com/images/add-2/vag1_20151001b.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Development and Delivery (ADD)]]></title>
    <link href="http://markfussell.emenar.com/blog/add-1/"/>
    <updated>2015-09-24T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/add-1</id>
    <content type="html"><![CDATA[<p>I have been paid to develop and deliver software since about 1980.  That is 35 years of professional experience.
When I started in 1980 there were a lot of 'old timers' who had been around since 1965 or so.  They were 15 years
ahead of me, and even after finishing college, I had less than ten years to their twenty or so.  This was both
intimidating but also very helpful: after college my main programming language was Smalltalk (ParcPlace, Digitalk, etc.),
which included full source to everything.  So the 'masters' would write masterpieces of code, and I would read them.  And then
try to write my own beautiful things leveraging the masterpieces.  I was late to the party, but could learn quickly.</p>

<p>I also have one other unusual advantage: I do startups.  Lots of startups (<a href="http://SlumsOfPaloAlto.com/">http://SlumsOfPaloAlto.com/</a>).  A total of ten software startups over a period of
a bit more than a decade.  Each of these startups failed for one reason or another, but each one <em>hugely</em> progressed in
how good my development team ran.  Eight, nine, and ten were <em>crazy</em> productive: I would run production servers for the
whole company at the same time that I built out the product.  Alone.  And generally way faster than the product management
team could keep up.  At PeerCase the product team actually asked me to <em>slow down</em> delivery so they could ponder what
they wanted for longer.  I literally went to Disney World during ASH (a medical conference) to prevent myself from
releasing new features I knew they wanted.  I was paid to <em>not work</em> (well, I was contracting at the time, so I stopped the
hourly billing clock, but my project bonus was the same).</p>

<h2>10x Productivity</h2>

<p>Besides doing startups, I also consult for companies.  I try to help them improve their development methods, usually by at least 4x if not 10x.
A lot of times, people don't believe you can improve things to '10x' the productivity of the current team using new
development and delivery techniques.  At one company, the CIO and a number of other executives believed me, but I had to convince
a lot more stakeholders.  So two amigos and I sent me into the trenches.  I started taking projects estimated as two-developers, six-months,
and doing them in one month.  Part time.  That is more than 12x productivity.  Realistically it was likely about 20x the productivity
because the teams tend to miss their estimates (they go over).</p>

<!-- more -->


<p>Then for fun, I was sent into the trenches again but this time had to use <em>some</em> of their development methods.  Still way faster,
but back down to 10x or a bit better.  As the trenches became "less mine" and "more theirs" I would slow down more and more.
Eventually everyone tired of each other and the experiments stopped.</p>

<p>Bizarrely, this company that saw the 20x continues to use the slow, unreliable, method of development.  The workers may have
been scared that the company would only need one in ten of them if they changed to a better method.</p>

<h2>Development Stagnation</h2>

<p>Again, I have been doing this for 35 years.  My skill as a developer has improved over that time, and I now view myself as an '8'
where each increase from '0' represents a doubling of business productivity.  So I am 256 times as productive as a '0', and 16 times
as productive as a '4'.  Stephen Wolfram, Bill Joy, and others are above me, but there are not a lot of people up there anymore.</p>

<p>Getting to be a '4' involves understanding how to program.  Getting to a '6' involves understanding business needs.  But getting to an '8'
involved an incredible / revolutionary change to how software is developed and delivered.  For most of my career, getting to an '8'
was not possible.  Or at least the scale had to be different (i.e. add 50% for each number vs. doubling).</p>

<p>The problem was that software development had made <em>absolutely no progress</em> for 40+ years.  "You lie!" people claim.  "We build software very
differently then we used to!" they say.  Yes, <em>some people</em> have made progress.  But it was people doing it wrong for 40+ years.  The
people who did it right (Xerox PARC, MIT's Lisp group, Xerox El Segundo, Tektronics, etc.) were buzzing along happily with a 4-10x speed
of the rest of the industry.</p>

<p>What is this amazing way to build software?  Well, for 40+ years, the best way to write software was to take a working computer and tweak it.
Then clone that. Voila: you have a new capability on all your computers.  Testing is trivial.  Demoing is trivial.  Fixing
is trivial.  Tweak.  Clone.  Repeat.  Smalltalk, Lisp Machines, Xerox Stars, and so on all used this model.  And they were
blazingly fast to develop on.  And to learn how to develop on.</p>

<p>If you wrote software any way different from that, you were just punishing yourself.  Your software would regress because
you touched too much and broke things.  Your software would take too long to write and be buggy because you wrote it
from scratch instead of tweaking something that worked.  Your software would not do what the business wanted because
you spent months writing it instead of hours tweaking something that was close.  Pain... pain... pain...</p>

<p>When I shifted to Java, I dropped to a '6' from an '8' in Smalltalk.  Lots of developers hated leaving Smalltalk
because of that.  But in my case, I cared about the libraries and people who were moving into Java.  It is not
a great language, but it had a lot of potential.  And Smalltalk imploded when Java was released for free.</p>

<h2>Automated Testing</h2>

<p>So I am in this crappy new language, dealing with jars (usually with source), deploying to containers, building out
linux servers in data centers, and trying to make this whole thing scale to millions of users and international
development teams who like to break my code.  It was fun and hell at the same time.  To avoid my going down to a '4'
because other people broke my code, I leveraged XP practices that were entrenched in startup #3 (Evant / Retail Aspect).
This was one of the first full-bore XP companies with Kent Beck and Rob Mee at the helm of the development team.</p>

<p>XP is very much oriented to "Write tests first".  That is stupid.  You need to figure out what you are doing and
writing tests is not a good way to figure out how to do something.  You <em>do it</em> to figure out how to do it.  But
after you <em>do it</em>, you should write tests to make sure the code still does it tomorrow.  Unfortunately, people
usually forget to write tests after, hence the XP maxim.  I lucked out and a whole bunch of tests existed
when I showed up.  I needed to scale the product to be 1-million times bigger and 1-thousands times faster.
And not break any existing test (unless we changed functionality).</p>

<p>That sold me on automated testing.  It made me slower (say a '5') but it protected me from other people breaking
my working code.  Eventually we used Excel for the automated tests, the business people wrote them directly, and
I was back to a '6'.</p>

<h2>Grails and Opinionated Frameworks</h2>

<p>I became an '8' again when I started using <a href="http://grails.org/">http://grails.org/</a>.  The language (Groovy and Annotated Java)
was now approaching Smalltalk if a bit uglier.  And the automated binding to the database, plugin model,
and other great features in Grails made it so I simply didn't have to worry about a lot of stuff.  I
was getting different benefits from Smalltalk, but they netted out.  And I had the same benefit as
Smalltalk in onboarding others: (1) This is the Grails way, (2) This is my 'tweaks' to the Grails way...
now start asking for features and build them.</p>

<h2>Flex and Angular</h2>

<p>On the client side, I had shifted to using Flex very early on for a company called Winster.  It was a bit
bleading edge at the time, but Flex was very powerful and very productive.  It was basically Smalltalk
on the client.  Eventually Flex/Flash became non-viable because of the iPhone issue, but then Angular
jumped in to replace it.  I tried others (e.g. YUI, Sencha, etc.) and they have pros-and-cons, but Angular
is very good and very Flex-like.</p>

<h2>Advanced Development and Delivery (ADD)</h2>

<p>OK, so above describes a lot of the stack I tend to use, but that isn't where the '256x' comes from.  Above I claimed
I was an '8' but that was on the old '50%' or maybe '70%' more scale.  On the new scale, I am a '6' with the stack above
<em>until</em> you add in the ADD: The Advanced Development and Delivery environment.</p>

<p>The ADD came to me incrementally from Evant, through my own failed attempt at productizing it (Velidom), and fully
germinated with my last software startup: Rumble.  "Amusingly", Velidom was killed by two of the four ingredients,
tried to work around problems with SVN that is replaced by one of the four ingredients, and included as part
of the product one of the four ingredients.  If we had just focused on that <em>one ingredient</em> and not the whole
software factory, Velidom would now be owned by Atlassian.</p>

<p>The four ingredients are:</p>

<ul>
<li>Amazon EC2 <a href="http://aws.amazon.com/">http://aws.amazon.com/</a></li>
<li>Amazon S3  <a href="http://aws.amazon.com/">http://aws.amazon.com/</a></li>
<li>GitHub.com <a href="http://github.com/">http://github.com/</a></li>
<li>HipChat    <a href="http://HipChat.com/">http://HipChat.com/</a></li>
</ul>


<p>These four ingredients, when baked properly together, give individuals and teams 4x or more productivity.  No, you
can not substitute the ingredients.  Not until you understand what they are and how they work together.  Yes, <em>I</em>
can substitute ingredients for the above, but the above are the current gold standard.  And hosting your own version
of any of these products is also a 'substitution' and not equivalent to using them as a service.</p>

<h3>Four Ingredients, Three Roles</h3>

<p><img width="432" height="414" src="http://markfussell.emenar.com/images/add-1/ADD_FourIngredients_ThreeRoles_mlf1a1.png" /></p>

<p>For more details or questions, please contact me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Being a git about everything (IT Automation [2])]]></title>
    <link href="http://markfussell.emenar.com/blog/git-about-everything-it-automation-2/"/>
    <updated>2013-02-19T18:16:00-08:00</updated>
    <id>http://markfussell.emenar.com/blog/git-about-everything-it-automation-2</id>
    <content type="html"><![CDATA[<p>This is the fifth in a series of using git as part of interesting solutions to problems.</p>

<p>The first is here: <a href="/blog/git-about-everything-intro/">Intro</a> and the previous
part of this topic is here: <a href="/blog/git-about-everything-it-automation/">IT Automation</a></p>

<h2>PushMePullYou or Leveraging git to enable mass-automated IT</h2>

<div style="float:right">
<img width="244" height="191" src="http://markfussell.emenar.com/images/git-about-everything-it-automation/Pushmepullyou_mlf1c.png" />
</div>


<p>The previous post dealt with the groundwork of having Git be a central part of IT automation.  That
showed the core idea but was a bit too simple to fully express the power of the approach.
This post will be dealing with all the things that were left off, especially support for:</p>

<ul>
<li> Many different types of servers with both their own and shared 'recipes'</li>
<li> More complicated install/upgrade actions</li>
<li> More sophisticated install behavior</li>
<li> Multiple versions of 'recipes' and an ability to promote whole IT from development to production</li>
<li> Getting information from other active repositories</li>
</ul>


<!-- more -->


<p>To just jump-in and not be so incremental, I want to build the following deployment:</p>

<ul>
<li> A load-balancing layer that registers itself with the outside world and knows how to talk to the application layer</li>
<li> An application layer that runs an application which may be updated at any time</li>
<li> A database layer using a cluster of Riak servers</li>
<li> A presence server that can record what servers are present (so other servers can leverage)</li>
</ul>


<p>Each of these will be a different stack for easier management.  There will also be a Control server
which makes setting up the deployment easier (for example, it will make sure you have the latest AWS CLI).</p>

<h2>The Control Server</h2>

<p>To get everything up and running check out the repository:</p>

<p><code>bash
git clone git://github.com/markfussell/giteveryrepo4.git
</code></p>

<p>And then in the Amazon AWS console launch the control server with the file template at <code>it/aws/cloudformation/GitEvery4ControlServer.template</code>.</p>

<p><img src="http://markfussell.emenar.com/images/git-about-everything-it-automation-2/create_control_stack.png" /></p>

<p>You can then SSH into the server and <code>sudo su -</code> to change to root. And <code>cd gitrepo/giteveryrepo4</code> to get into the root of the repository.</p>

<p><img src="http://markfussell.emenar.com/images/git-about-everything-it-automation-2/control_server_login.png" /></p>

<h2>Handling Different Types of Servers</h2>

<p>A major difference from the previous example is there are now several types of servers, and they
will have different:</p>

<ul>
<li> Firewall permissions</li>
<li> Initial setup of software</li>
<li> Ongoing configuration changes</li>
</ul>


<p>There are also a number of similarities and ideally the CloudFormation files are as similar and
simple as possible.</p>

<h3>Firewall Permissions</h3>

<p>One major change is to get rid of stack-generated security groups: these are difficult to manage since
they have ever-changing and obscure names.  I believe it is better for any real deployment to control
the security groups independently of the Stacks.  So now we have two kinds of security groups:</p>

<ul>
<li> One for the <code>deployment</code> as a whole</li>
<li> One for each <code>part</code> a server node can be</li>
</ul>


<p>The <code>deployment</code> and <code>part</code> are assigned as constants in the Stack template mappings:</p>

<p>```json
  "Mappings" : {</p>

<pre><code>"TemplateConstant" : {
   "stacktype" : { "value" : "GitEvery4LbServer" },
   "initgitrepo" : { "value" : "giteveryrepo4" },
   "nodepart" : { "value" : "applbnode" },
   "deployment" : { "value" : "testdeployment" }
},
</code></pre>

<p>```</p>

<p>and then later referenced in the security group section:</p>

<p>```json</p>

<pre><code>    "SecurityGroups" : [ { "Fn::FindInMap" : [ "TemplateConstant", "deployment", "value" ] }, { "Fn::FindInMap" : [ "TemplateConstant", "nodepart", "value" ] } ],
</code></pre>

<p>```</p>

<p>Before we create the stack, we create the appropriate groups.  For example, the <code>deployment</code> group will enable SSH into
the nodes and any node within the deployment to talk to any other node:</p>

<p>```bash</p>

<h1>===================</h1>

<h1>=== testdeployment</h1>

<h1>===================</h1>

<p>ec2-create-group testdeployment -d  testdeployment
export OWNER=<code>ec2-describe-group | grep GROUP | head -n 1 | cut -f 3</code></p>

<h1>Enable SSH In</h1>

<p>ec2-authorize testdeployment -p 22 -s 0.0.0.0/0</p>

<h1>Enable deployment to talk to itself</h1>

<p>ec2-authorize testdeployment -o testdeployment -u ${OWNER}</p>

<p>```</p>

<h3>Initial setup of software</h3>

<p>Within the CloudFormation template, we use the same approach as last time: simply checkout a git repository and call into it.  In Bash it would be:</p>

<p><code>``bash
yum -y install git
mkdir /root/gitrepo
cd /root/gitrepo
git clone git://github.com/markfussell/</code>cat /root/nodeinfo/initgitrepo.txt`.git</p>

<p>cd /root/gitrepo/<code>cat /root/nodeinfo/initgitrepo.txt</code>
include () { if [[ -f "$1" ]]; then source "$1"; else echo "Skipped missing: $1"; fi }
include bin/init/common/init.sh
```</p>

<p>which is converted to JSON (string-quoted) within the template.</p>

<p>This entering on a common <code>init.sh</code> entrypoint makes the CloudFormation stacks simpler and more general.  It is much
easier to update and push to the git repository than to update all the stacks that are using the repository.</p>

<p>The new part is now at the end of the common entrypoint: jumping into more specific initialization depending
on the properties of the node:</p>

<p><code>bash
include bin/init/part/`cat /root/nodeinfo/nodepart.txt`/init.sh
include bin/init/stacktype/`cat /root/nodeinfo/stacktype.txt`/init.sh
include bin/init/stacktype/`cat /root/nodeinfo/stacktype.txt`/part/`cat /root/nodeinfo/nodepart.txt`/init.sh
</code></p>

<p>We so far have three variations:</p>

<ul>
<li> The <code>part</code></li>
<li> The <code>stacktype</code></li>
<li> Combining both of the above.</li>
</ul>


<p>We can be as general or as specific as we want.</p>

<p>A <code>stacktype</code> is simply the name of the template (vs. the name of an instantiated stack which has to be unique).
The main advantage of <code>stacktype</code> is it allows easy separation of behavior by kind of stack and
also allows versioning if <code>stacktype</code> includes a version number.</p>

<p>A <code>part</code> is the singular role a node plays within a deployment.  I use <code>part</code> instead of <code>role</code> to avoid
conflict with Chef where a node can have many roles.  A node has exactly one <code>part</code> it plays in the deployment,
and each <code>part</code> can have any number of <code>roles</code>.  A <code>part</code> should normally be fairly universal.  In our case
the five parts are <code>applbnode</code> (The main application load balancer), <code>appnode</code> (The main app), <code>riaknode</code> (The
riak database node), <code>presencenode</code> (A server presence recording server), and <code>controlnode</code> (The main launching
control server, which isn't really part of the running deployment).</p>

<p>With just the application and load-balancing parts/nodes running along with the controlnode, we have something like this:</p>

<p><img src="http://markfussell.emenar.com/images/git-about-everything-it-automation-2/pushmepullyou_lbandappawsarch.png" /></p>

<p>Each <code>part</code> has its own stack template and instance, which creates one or more nodes of that <code>part</code> type.</p>

<p>...More To Come...</p>

<h2>References</h2>

<ul>
<li> <a href="http://bitfieldconsulting.com/scaling-puppet-with-distributed-version-control">http://bitfieldconsulting.com/scaling-puppet-with-distributed-version-control</a></li>
<li> <a href="http://blog.afistfulofservers.net/post/2012/12/21/promises-lies-and-dryrun-mode/">http://blog.afistfulofservers.net/post/2012/12/21/promises-lies-and-dryrun-mode/</a></li>
</ul>


<h2>Next</h2>

<p>Our next problem will be...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Being a git about everything (IT Automation)]]></title>
    <link href="http://markfussell.emenar.com/blog/git-about-everything-it-automation/"/>
    <updated>2013-02-16T18:16:00-08:00</updated>
    <id>http://markfussell.emenar.com/blog/git-about-everything-it-automation</id>
    <content type="html"><![CDATA[<p>This is the fourth in a series of using git as part of interesting solutions to problems.</p>

<p>The first is here: <a href="/blog/git-about-everything-intro/">Intro</a></p>

<h2>Leveraging git to help enable automated IT</h2>

<p>Doing IT for computers involves installing software, configuring things, doing backups, updates, etc.
The ultimate IT is one that <em>'simply works'</em> and involves almost no human interaction
even in failure situations.  Ideally IT should be equivalent to
a macro-level program that does everything that does not require touching
a physical machine.</p>

<p>This IT-as-program has become easier and easier over the last many years with
better and more standardized operating systems, free software that does not
require annoying human interaction during installation, and virtualization on top of physical
hardware that makes provisioning and reprovisioning easier.  With cloud computing,
IT-as-program becomes almost a necessity as hundreds of virtual computers are created, updated, failed,
migrated, and decommissioned.</p>

<p>Git alone doesn't enable IT-as-program but it can be a core component in many areas.  Among these are:</p>

<ul>
<li> Easy 'Live IT' servers</li>
<li> A Push-Me-Pull-You model for continual deployment</li>
<li> Server presence</li>
</ul>


<p>Having git as a core piece of IT infrastructure enables thousands of machines to very rapidly react (within a minute or two)
without needing a heavy infrastructure.  You simply need one or two (for redundancy) git servers, of which one can be GitHub
or a similar free or inexpensive service.  Other technologies in this space have significantly more complicated servers,
are more likely to be SPOFs (Single points of failures) or bottlenecks, and are much more expensive as a service.</p>

<!-- more -->


<h2>Easy 'Live IT' servers</h2>

<p>A 'Live IT' server is one that can automatically do new things when something about the IT world changes.  This
is not referring to how sophisticated the applications on a server are, but whether the server itself can
manage upgrades or other configuration changes to itself.  Examples are:</p>

<ul>
<li> Deploying new version of a Java war or a Rails app</li>
<li> Doing database backups and offloads</li>
<li> Offloading or deleting logs (that are harder than logrotate)</li>
<li> Reacting to simple configuration changes</li>
<li> Reacting to server presence changes</li>
</ul>


<p>There are a number of ways to do the activities listed above, from manually interacting with machines, through cron jobs,
mass 'push' model interactions (e.g. Capistrano), and finally puppetry via Chef and similar.  I have found almost all of
these to be lacking in many ways, including:</p>

<ul>
<li> Lack of documented change-to-server</li>
<li> Difficulty in rolling back changes</li>
<li> Not scaling nicely (one client hitting many servers, or many servers doing queries against another server)</li>
<li> Lack of flexibility</li>
<li> Slowness or non-responsiveness (delays) of applying changes</li>
<li> Differences from 'bootstrap' of cloud servers</li>
</ul>


<h3>Pull Model</h3>

<p>A different approach leveraging Git (or any other DVCS) seems to produce much simpler and more powerful
solutions.  The approach is composed of:</p>

<ul>
<li> A git repository that has working scripts (in any language people like, including Chef-solo)</li>
<li> A simple bootstrap script that clones the repository and calls an <code>init.sh</code> script in it</li>
<li> A cron job that is set up by the <code>init.sh</code> script.  This cron job executes every minute

<ul>
<li>Goes into the working git repository</li>
<li>Does a pull to get the latest version of scripts</li>
<li>Then calls into a <code>work.sh</code> script</li>
</ul>
</li>
</ul>


<p>This flow enables activity at every minute, using the latest version of the git repository, and with very little overhead
for the core behavior.  Advantages are:</p>

<ul>
<li> All changes to a server are caused by one or more git repositories changing.  Servers can even publish there status by showing the git revision they are on.</li>
<li> Rolling back changes is simply reversing a commit</li>
<li> The only centralized activity is the <code>git fetch</code> which is very simple and fast.</li>
<li> So far the only constraint is the time is every minute, and that could be sub-minute but needing that is rare</li>
<li> Delays are at most a minute, and again that could easily become less (but not sub-second)</li>
<li> The behavior is actually the same as bootstrapping a server.  A bootstrap is just the first minute of work.</li>
</ul>


<h3>Example-1</h3>

<p>Example-1 is the initial example of this model.  The repository is</p>

<ul>
<li> <a href="https://github.com/markfussell/giteveryrepo3/">https://github.com/markfussell/giteveryrepo3/</a></li>
</ul>


<p>with the CloudFormation template being:</p>

<ul>
<li> <a href="https://github.com/markfussell/giteveryrepo3/blob/master/it/aws/cloudformation/GitEverythingServer3.template">https://github.com/markfussell/giteveryrepo3/blob/master/it/aws/cloudformation/GitEverythingServer3.template</a></li>
</ul>


<p>This has a UserData section which does the initial bootstrap of cloning the repository and
calling an init script inside it.</p>

<p>```json</p>

<pre><code>      "yum -y install git \n",
      "mkdir /root/gitrepo \n",
      "cd /root/gitrepo \n",
      "git clone git://github.com/markfussell/giteveryrepo3.git  \n",

      "cd /root/gitrepo/giteveryrepo3 \n",
      "source bin/init/common/init.sh \n",
</code></pre>

<p>```</p>

<p>The <code>init.sh</code> script simply sets up a cron job that calls the <code>cron_1m.sh</code> script
in <code>/root/bin/</code>.  I prefer to have crontab files that are very simple (e.g. one line)
and call into /root/bin/ scripts so (a) it is more visible what crons are running
(b) if there are any inter-cron issues they can be managed, and (c) it is easy to
disable a cron by doing a rename.</p>

<p>The <code>init.sh</code> file:</p>

<h1>```bash</h1>

<h1>=== Have a preference that crons</h1>

<h1>=== all go through a single file</h1>

<h1>================================</h1>

<p>mkdir -p /root/bin
cp ./bin/init/common/cron_1m.sh /root/bin/cron_1m.sh
chmod +x /root/bin/cron_1m.sh</p>

<p>cat &lt;<EOS > /var/spool/cron/root
MAILTO=""</p>

<ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>/root/bin/cron_1m.sh
EOS</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>```</p>

<p>And the <code>cron_1m.sh</code> file:</p>

<p>```bash</p>

<h1>! /bin/bash</h1>

<h1>================================</h1>

<h1>=== Simple worker example</h1>

<h1>================================</h1>

<p>export ME=<code>basename $0</code>
export LOG=/root/log/${ME}<em>log.txt
export ERROR=/root/log/${ME}</em>error.txt
export START_TSS="<code>date +%Y%m%d-%H%M%S</code>"</p>

<p>mkdir -p /root/log/</p>

<p>exec 1>> ${LOG}
exec 2>> ${ERROR}</p>

<p>echo "${ME}: Start  ${START_TSS}" >> ${LOG}</p>

<p>export REPOS=<code>find /root/gitrepo/ -maxdepth 1 -mindepth 1</code>
for REPO in ${REPOS}; do</p>

<pre><code>pushd ${REPO}
    git pull

    source bin/work/common/work.sh
popd
</code></pre>

<p>done</p>

<p>export FINISH_TSS="<code>date +%Y%m%d-%H%M%S</code>"
echo "${ME}: Finish ${FINISH_TSS}" >> ${LOG}</p>

<p>```</p>

<p>As you can see the <code>cron_1m.sh</code> script is "repo flexible".
It will do any and all <code>work.sh</code> file it finds in the repositories under
<code>/root/gitrepo/</code>.  You might want to be more restrictive than
that (say only 'active' repos), but this at least shows the power of the
generalization.</p>

<p>If you login to the server, you will find it doing some kind of work:</p>

<p>```bash
[root@ip-10-120-174-182 ~]# tail -f /root/log/*
==> /root/log/cron_1m.sh_error.txt &lt;==</p>

<p>==> /root/log/cron_1m.sh_log.txt &lt;==
Already up-to-date.
We are doing some kind of work
~
cron_1m.sh: Finish 20130219-050202
cron_1m.sh: Start  20130219-050301
~/gitrepo/giteveryrepo3 ~
Already up-to-date.
We are doing some kind of work
~
cron_1m.sh: Finish 20130219-050301</p>

<p>```</p>

<p>As you can see, the total time to do a "Hello World" is under a second.  Very fast!</p>

<h4>Inherent overhead of approach</h4>

<p>The amount of overhead associated associated with this approach is less than a second.  The fetch itself:</p>

<p>```bash
[root@ip-10-120-174-182 giteveryrepo3]# time git fetch</p>

<p>real    0m0.087s
user    0m0.002s
sys 0m0.006s
```</p>

<p>is 87 milliseconds and the system overhead is 8 milliseconds on an m1.small (that isn't doing anything else).
With a busier server the 'real' time goes up a bit, but the system overhead is still tens of milliseconds at
most.</p>

<p>Although fetching is useful on its own, we will initially always merge as well, so let us time that:</p>

<p>```bash
[root@ip-10-120-174-182 giteveryrepo3]# time git pull
Already up-to-date.</p>

<p>real    0m0.105s
user    0m0.007s
sys 0m0.053s
```</p>

<p>Pulling requires a bit more effort to do a no-op merge but things are still in the tens of milliseconds of 'effort'
and a clock time well under a second.</p>

<h2>Push-Me-Pull-You</h2>

<div style="float:right">
<img width="244" height="191" src="http://markfussell.emenar.com/images/git-about-everything-it-automation/Pushmepullyou_mlf1c.png" />
</div>


<p>The previous section discussed having 'Live IT' servers that use the very-fast git pull to
get updates that the server will react to.  Updating central git repositories uses an atomic 'push'
operation, so the obvious name for this pattern of pushing changes from one place (say 'me')
to a hundred servers who are listening (let us call them 'you') is... 'Push-Me-Pull-You'...
which even has a handy mascot.</p>

<p>Some great things about the PushMePullYou were identified above:</p>

<ul>
<li> Extremely low overhead and very simple model</li>
<li> All changes to a server are caused by one or more git repositories changing.  Servers can even publish there status by showing the git revision they are on.</li>
<li> Rolling back changes is simply reversing a commit</li>
<li> The only centralized activity is the <code>git fetch</code> which is very simple and fast.</li>
<li> So far the only constraint is the time is every minute, and that could be sub-minute but needing that is rare</li>
<li> Delays are at most a minute, and again that could easily become less (but not sub-second)</li>
<li> The behavior is actually the same as bootstrapping a server.  A bootstrap is just the first minute of work.</li>
</ul>


<p>A few additional ones are:</p>

<ul>
<li> You can 'push' from anywhere you want... so you can test a change on the target IT environment and then push from there if it works</li>
<li> It is very easy to organize many different kinds of machines, kinds of deployments, etc. within a single repository</li>
<li> It is very easy to detect whether a change happens at all, whether it is potentially relevant, and with a few easy patterns, whether it would have an impact that requires real action</li>
</ul>


<p>The architectural model looks a bit like this</p>

<p><img src="http://markfussell.emenar.com/images/git-about-everything-it-automation/pushmepullyou_simpleawsarch.png" /></p>

<h3>Going beyond naive</h3>

<p>The Example-1 above had the naive 'pull and do something no matter what'.  We need to get a bit beyond that
to have a truly useful approach.</p>

<h3>Checking commit version</h3>

<p>The simplest sanity check is to see whether we have a new commit.  This can be done in a few ways, including:</p>

<ul>
<li> Do a 'fetch' and check whether the remote branch is different from the local branch</li>
<li> After each action, store the commit version that was acted upon.  On each pull compare the old to the new</li>
<li> Have a local acted-upon branch separate from the main branch</li>
</ul>


<p>The last one has a nice feature of showing 'history-according-to-this-machine' where the other two are purely
'what is now', but it is simpler to avoid having a per-machine branch and multiple versions (the differing
merges depending on local history) occurring
everywhere.</p>

<h4>Fetch based</h4>

<p>The simplest check is just to see if there are any differences between the 'origin' and the local branch.  This
would look something like <code>detectOriginFetchDiff.sh</code>:</p>

<p>```bash</p>

<h1>=================================================</h1>

<h1>=== Detect whether the version of the origin</h1>

<h1>=== is the same as the local version.</h1>

<h1>=== Return the ORIGIN_VERSION if different</h1>

<h1>=================================================</h1>

<p>git fetch</p>

<p>export ORIGIN_VERSION=<code>git rev-parse origin/master</code>
export LOCAL_VERSION=<code>git rev-parse HEAD</code></p>

<p>if [ "${ORIGIN_VERSION}" = "${LOCAL_VERSION}" ]; then</p>

<pre><code>: #Don't do anything
</code></pre>

<p>else</p>

<pre><code>echo ${ORIGIN_VERSION}
</code></pre>

<p>fi
```</p>

<p>Where you can use this script with:</p>

<p><code>bash
if [[ -n "`./bin/pushmepullyou/detectOriginDiff.sh`" ]] ; then
   : #React to the change
else
   : #Do nothing / exit
fi
</code></p>

<p>This should be lightning fast.  The only drawback is:</p>

<ul>
<li> If you don't pull (merge) until after executing the script... you might not be able to easily change the code determining whether to executing the script</li>
</ul>


<p>You can redo an action by forcing the local branch back a version.  For example:</p>

<p><code>bash
git reset --hard master~1
</code></p>

<h4>Last-action based</h4>

<p>An alternative to the fetch-based model is to record the last action performed by the local machine.  This
deals with the drawback above: you already have the latest version of code no matter what.  Also it starts
down the path of 'mid-action' protection (to avoid doing a change or sequence of changes on top of each
other).  For example <code>detectLastActionDiff.sh</code>:</p>

<p>```bash</p>

<h1>=================================================</h1>

<h1>=== Detect whether the last action version</h1>

<h1>=== is the same as the current pulled version.</h1>

<h1>=== Return the LOCAL_VERSION if different</h1>

<h1>=================================================</h1>

<p>export LOCAL_VERSION=<code>git rev-parse HEAD</code>
export LASTACTION_FILE=./.temp/nodeinfo/lastaction.txt</p>

<p>if [[ -e ${LASTACTION_FILE} ]]; then</p>

<pre><code>export LAST_ACTION=`cat ${LASTACTION_FILE}`
if [ "${LAST_ACTION}" = "${LOCAL_VERSION}" ]; then
    : #Don't do anything
else
    echo ${LOCAL_VERSION}
fi
</code></pre>

<p>else</p>

<pre><code>echo ${LOCAL_VERSION}
</code></pre>

<p>fi
```</p>

<p>And after completing any action you write the version into the lastaction version file:</p>

<p>```bash</p>

<p>export LOCAL_VERSION=<code>git rev-parse HEAD</code>
export LASTACTION_FILE=./.temp/nodeinfo/lastaction.txt
export LASTACTION_DIR="$( cd -P "$( dirname "${LASTACTION_FILE}" )" &amp;&amp; pwd )/"</p>

<p>mkdir -p LASTACTION_DIR
echo ${LOCAL_VERSION} > ${LASTACTION_FILE}
```</p>

<h3>Avoiding mid-action collision</h3>

<p>The main advantage of the Last-action approach is it starts down the path of
making sure you are not executing things twice.  Alternatively, you could
have an <code>flock</code> associated with the calling script (say the <code>cron_1m.sh</code>),
but writing to a <code>currentaction</code> file is a bit more
OS independent, can document what version is being acted upon,
and supports multiple paths hitting the same file.</p>

<p>Ideally if anything is currently working, the automatic <code>merge</code> would stop,
so the test for <code>currentaction</code> should be very early.  We should go
back to our initial worker example</p>

<p>```bash</p>

<h1>! /bin/bash</h1>

<h1>================================</h1>

<h1>=== Simple worker example</h1>

<h1>================================</h1>

<p>export ME=<code>basename $0</code>
export LOG=/root/log/${ME}<em>log.txt
export ERROR=/root/log/${ME}</em>error.txt
export START_TSS="<code>date +%Y%m%d-%H%M%S</code>"</p>

<p>export CURRENTACTION_FILE=./.temp/nodeinfo/currentaction.txt</p>

<p>mkdir -p /root/log/</p>

<p>exec 1>> ${LOG}
exec 2>> ${ERROR}</p>

<p>echo "${ME}: Start  ${START_TSS}" >> ${LOG}</p>

<p>export REPOS=<code>find /root/gitrepo/ -maxdepth 1 -mindepth 1</code>
for REPO in ${REPOS}; do</p>

<pre><code>pushd ${REPO}
    if [[ -e ${CURRENTACTION_FILE} ]]; then
        : #Don't do anything until the current action completes
    else
        git pull

        bash bin/work/common/work.sh
    fi
popd
</code></pre>

<p>done</p>

<p>export FINISH_TSS="<code>date +%Y%m%d-%H%M%S</code>"
echo "${ME}: Finish ${FINISH_TSS}" >> ${LOG}</p>

<p>```</p>

<blockquote><p>Note: If you want to have each repository have more control of it's behavior
you would need to move the <code>if</code> test and the <code>pull</code> into the work file.</p></blockquote>

<p>While the action is running you can either touch or copy
the current version into <code>currentaction</code>, and when
finished, delete or rename it.  Since everything
is running so fast, you probably don't need to do
an <code>flock</code> or even a second <code>[[ -e ]]</code> check.  Acquiring
the lock is simply:</p>

<p><code>``bash
export LOCAL_VERSION=</code>git rev-parse HEAD`
export CURRENTACTION_FILE=./.temp/nodeinfo/currentaction.txt
export CURRENTACTION_DIR="$( cd -P "$( dirname "${CURRENTACTION_FILE}" )" &amp;&amp; pwd )/"</p>

<p>mkdir -p CURRENTACTION_DIR
echo ${LOCAL_VERSION} > ${CURRENTACTION_FILE}</p>

<h1>Now officially own the current action</h1>

<p>```</p>

<h3>Dealing with different types and collections of servers</h3>

<p>All the above had a single type of machine watching any changes in the
repository and doing the same thing.  Although this does work if you
have either very few servers or are happy with a plethora of repositories
or branches, it would be good to have a way for many different types
and collections of servers to share a single repository.  We
will deal with that in the next blog.</p>

<h2>Summary</h2>

<p>Git can help automate IT with a very fast and effective PushMePullYou
model.  Hundreds of servers can be continually polling one or more
central Git servers to see if anything has changed and then act
upon those changes.  This provides history for any activity, a
very fast response time, and almost no load when nothing has changed.
Also, this approach enables bootstrapping and updating to use exactly
the same paths.</p>

<p>In all, it provides a superior foundation for IT automation in spite of
being so simple.</p>

<h2>References</h2>

<ul>
<li> Chef-Server Scalability

<ul>
<li><a href="http://lists.opscode.com/sympa/arc/chef/2012-01/msg00422.html">http://lists.opscode.com/sympa/arc/chef/2012-01/msg00422.html</a></li>
<li><a href="http://www.opscode.com/hosted-chef/">http://www.opscode.com/hosted-chef/</a></li>
</ul>
</li>
</ul>


<h2>Credit</h2>

<ul>
<li> Initial Llama for Push-Me-Pull-You Image credit: <a href='http://www.123rf.com/photo_11398752_llama-llove--two-llamas-kiss-their-necks-forming-a-heart-shape.html'>fiftyfootelvis / 123RF Stock Photo</a></li>
</ul>


<h2>Next</h2>

<p>Our next problem will be <a href="/blog/git-about-everything-it-automation-2/">Mass IT Automation</a></p>
]]></content>
  </entry>
  
</feed>
