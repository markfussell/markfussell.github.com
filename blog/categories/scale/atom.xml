<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scale | Polyglot]]></title>
  <link href="http://markfussell.emenar.com/blog/categories/scale/atom.xml" rel="self"/>
  <link href="http://markfussell.emenar.com/"/>
  <updated>2015-11-30T13:14:53-08:00</updated>
  <id>http://markfussell.emenar.com/</id>
  <author>
    <name><![CDATA[Mark Fussell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[READ: Scaled Agile]]></title>
    <link href="http://markfussell.emenar.com/blog/read-2/"/>
    <updated>2015-11-20T01:00:00-08:00</updated>
    <id>http://markfussell.emenar.com/blog/read-2</id>
    <content type="html"><![CDATA[<p>This is the fourth series describing the ADD: a radically more productive software development and delivery
environment.  This series is on estimation, and the first part is here: <a href="/blog/read-1">ADD: Estimation</a>.</p>

<h2>Scaled Agile</h2>

<p>As mentioned at the end of the first part, the extreme reaction to waterfall was to toss Analysis and Design
away, and go from very-loose requirements into actual implementation.  I believe this was a complete mistake
and has caused these "extreme" agile projects to be much <em>slower</em> and <em>unstable</em> compared to another approach.</p>

<p>The alternative is "Scaled Agile", and by this I mean both:</p>

<ul>
<li>It is better designed for larger projects</li>
<li>It is achieved by scaling the activities of software development projects to be appropriate for the scale and needs of the project

<ul>
<li>Analysis &amp; Design efforts, deliverables, and precision can be smaller or larger</li>
<li>Increments of delivery can be smaller or larger</li>
<li>Allowance for iteration (repeating something to refine it) can be smaller or larger</li>
<li>Overlap of activities can be smaller or larger</li>
</ul>
</li>
</ul>


<p>The second item was tossed out with the "Waterfall", at least by many in the industry.  A Waterfall is an extreme version of Agile (basically
no during-build agility), but going directly from verbal or spread-sheet based requirements is a similarly extreme version of Agile
and is unlikely to be as effective as properly-scaled versions of Agile.</p>

<h3>Retail Aspect / Evant / XP / Scaled Agile</h3>

<p>In 2003, while at Evant, we took an XP-based product (an advanced retail planning system) and worked on scaling the velocity and
agility of that project:</p>

<ul>
<li>To a bigger and non-XP team</li>
<li>Through multiple time-zones, including to India</li>
<li>Outside the development team into Product Management, Technical Sales, Marketing, and Support</li>
<li>Into a bigger portfolio of products that had inter-dependent deliverables</li>
<li>Across the portfolio to other product lines and teams</li>
</ul>


<!--more-->


<p>Evant was eventually acquired and folded into a larger company, so much of the memory of what worked well and not about
this was lost.  Except the person who had the 'APT' charter for Evant is still alive and cognizant.  And maybe a bit
opinionated, but will try to be objective.</p>

<p>Ultimately, I think the scaling "worked in principle" but having a pure XP team shift to Scaled Agile is asking them
to give up an almost religious desire to "Not Analyze", "Not Design", and "Not be Objectively Measured!".  If the
software developers really think they can program without being measured around productivity of delivering value to the
customer, you really have to let them go.  Maybe you have a wizard or two that makes crazy amazing things happen and you
don't bother putting them into the normal project teams, but beyond that, you need to know if your products, projects,
and programs are <em>delivering a good ROI</em> and how you could make them deliver a better ROI.</p>

<p>To do that, you need to measure.  And returning to COSMIC, it is a way to measure the scale of software functionality.
Which isn't the value to the customer of that system, but does reasonable express the complexity in providing the
value to the customer.</p>

<h3>COSMIC Measurement: Analysis and Design</h3>

<p>The COSMIC process is clearly doing Analysis and Design, but in a relatively light and tunable way.  You can control:</p>

<ul>
<li>How much you decompose a system</li>
<li>The detail level and decomposition of the functional users of the system</li>
<li>How detailed you get with "Objects of Interest" and their corresponding "Data Groups"</li>
<li>What scope of the system you are going to measure</li>
<li>The granularity and formality of the functional user requirements (FURs)</li>
<li>Details around the non-FURs (indirect FURs, non-functional requirements, and other constraints)</li>
</ul>


<p>Doing the COSMIC measurement process is basically doing a minimal Analysis and Design on a system, so you have a good
basis for measuring its size and correlating that to development costs.  But it doesn't just support the measurement,
it starts building a model of the user concepts (Object of Interests), their events, the system actions, and the
system components (based on the decomposition level).</p>

<h3>The Hub: Additional (or Not) Analysis and Design</h3>

<p>The COSMIC analysis can be a basis to additional investment in Analysis and Design, but that is optional.  That
is a choice of <em>delivery</em>.  You could have extreme delivery that ignored the COSMIC scope model completely.  Or
you could have extreme delivery that went into Waterfall after the COSMIC model was produced.  Or more sensibly,
you could start working <em>outward</em> from that hub:</p>

<ul>
<li>Does the minimal user concepts start describing a good logical data model?</li>
<li>Does the decomposition work with the implementation frameworks?  Should these be more fully designed or just implemented and noted how they are different.</li>
<li>If there is a lot of data-reading by different functional processes, are these from a single database or many or cached?</li>
</ul>


<p>Note that these 'expansions' are not meant to alter the Hub: The measurement was done, and you can leave it alone
but leverage it for subsequent activities</p>

<h3>The Hub: Drilling down with COSMIC</h3>

<p>Alternatively, as you do analysis and design, you can produce a new granularity and scope that you want to now
measure again.  This could be done only when things seem to have become <em>very</em> different from original expectations,
or consistently to understand development 'hidden requirements' or really 'derived requirements' growth.  The
measurement should still ignore NFRs, but the deeper granularity and the conversion of some NFRs to FURs would
cause a different estimate of 'Joints' because we have a different (more detailed) view of the system.</p>

<h3>Scaled Agile Manifesto</h3>

<p>I believe the Agile Manifesto was reactionary and extreme.  It had good ideas in it, but was missing core premises
that customers and development teams should expect from a good development project:</p>

<p>Manifesto:</p>

<ul>
<li>The Customer is always right about what they want.  The delivery team should always be honest and informative about what they can deliver and how they are doing it.

<ul>
<li>The Customer can change what they want, change the delivery team they use, but they can't interfere within the delivery team</li>
<li>The delivery team should always deliver a functional-requirements-based estimate of a project independent of the technology and other delivery choices, so the customer knows what they are asking for (compared to other projects) and getting (given the delivery approach)

<ul>
<li>Unless the customer clearly says "I don't care", in which case the delivery team can choose whether to do the work for their own internal benefit</li>
</ul>
</li>
</ul>
</li>
<li>Unless it helps a customer figure out what they want, requirement-fulfilling working systems are the only true progress of a project</li>
<li>A customer can desire to go forward to later stages (analysis, design, and implementation) before they are sure what they want

<ul>
<li>The cost of responding to change should be minimized while still supporting maximal ROI and velocity if there are no changes</li>
</ul>
</li>
<li>Processes and tools are to support the Customer and Ddelivery team's needs, and not ends of themselves.

<ul>
<li>A default or customary usage of processes and tools is appropriate, but should be evaluated if there appears to be no need or even clear counter-benefit</li>
</ul>
</li>
</ul>


<p>Principles:</p>

<ul>
<li>Our highest priority is to satisfy our current customers

<ul>
<li>Through techniques that enable the customer to make good decisions, see verifiable progress toward their goals, and determine if they are getting a good ROI</li>
</ul>
</li>
<li>Our second highest priority is to satisfy future customers even better

<ul>
<li>Through evaluation of what went well and poorly, and looking for ways to give even higher satisfaction (whether ROI, predictability, or in other ways) to customers</li>
</ul>
</li>
<li>Both sides should care about each other:

<ul>
<li>A happy development team that cares about the customer is usually better at satisfying the customer</li>
<li>A customer that truly cares about the development team is usually better at inspiring the team to deliver its best</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADD: Estimation]]></title>
    <link href="http://markfussell.emenar.com/blog/read-1/"/>
    <updated>2015-10-23T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/read-1</id>
    <content type="html"><![CDATA[<p>This is the fourth series describing the ADD: a radically more productive software development and delivery
environment.  The first series starts here: <a href="/blog/add-1/">Advanced Development and Delivery</a> and described the core four ingredients
of the ADD.  The second series starts here: <a href="/blog/addstack-1/">ADD Stack</a> and described the application stack and
system components associated with the ADD.  Some of these were Java / Grails specific, and some were more general
components and capabilities.  Together these went through a huge amount of functionality, flexibility, reliability,
and scalability.  Both for the IT infrastructure (whether on EC2 or on bare hardware) and for the applications
on top of that IT infrastructure. The third series starts here: <a href="/blog/add2-1">Advanced Development and Delivery Summary</a>
and gave an executive summary of the ADD.</p>

<p>This series is about project estimation, and is basically <em>orthogonal</em> to the ADD itself.  You can have good
 estimates or bad estimates.  The ADD delivers exceptional productivity.  How much you need to estimate is
 quite independent of productivity.  But by using Estimation and Feedback, you can figure out (a) whether
 to do a project and (b) whether the people you have are up-to-snuff.  If you <em>know</em> you have to do
 a project and you <em>have</em> certain people: don't worry about the estimate.  It is irrelevant.  Just "wing it".
 But if you have choices about either (a) whether to do a project or (b) what people to use or even (c)
 figuring out how good your team is after you do a project, then estimations are the core benchmark to
 give you feedback.</p>

<h2>Estimation is crazy-hard</h2>

<p>The problem with estimating is you can't be good at it unless you have done something very similar before.  But
most workers in an industry are relatively new to it: less than ten years.  And if each project takes a couple
years to complete, you may have only a couple experiences in your first five years of work.  Change technologies,
change roles, or change organization, and your estimates are likely poorly based.</p>

<p>When something is too hard for someone to do easily, you need to decompose it to make it (a) easier and (b) separable.</p>

<!--more-->


<p>Doing two or more pieces sequentially is commonly easier than doing the whole task at one time.  By easier, I don't
mean faster.  It may take more time, especially if there is some interrelationship between the pieces.  But there
is commonly a limit to how much a human brain can do at one time until they are trained.  Over time, the training
in the pieces enables them to be done simultaneously.  Master chefs and similar tend to be trained in all pieces of
  their craft until they can do it all so easily that they can do it simultaneously.</p>

<p>By making the pieces separable, you can have different people work on each of the pieces, and develop the skills
   needed for that piece alone.  Note that this isn't "slicing" a large piece of work into a smaller piece of work which
   requires all the same skills.  That would be like a chef doing part of the dinner service.  Instead it is
   separating the skills needed for the task: one chef "Plates" and just plates, another cooks meats, another cooks vegetables,
   another makes sauces, and so on.</p>

<p>The critical question is then how to decompose?  First we need to define and decompose what we mean by estimation.  And to do
that, we can put estimation into the macro solution-delivery process of software.</p>

<h2>A Framework: READ-OR</h2>

<p>I have been reading and writing software for about 35,000 hours.  Mostly reading, which I believe is the core
to being a great programmer: read great programmers' code and you will learn from it.  It may be hard to find
great code to read, but you can always start with Smalltalk or find some epic system close to the
kinds of systems you build.</p>

<p>Working through possible acronyms for the bigger software development process, I stumbled upon my favorite word: "READ".
All software is developed through this simple approach and acronym:</p>

<ul>
<li>Requirements of Solution – Given the problem, and what is your solution to that problem?  What does that solution require to solve the problem?</li>
<li>Estimation of Size – What is the estimate of the <em>size</em> of the solution?  Note this is independent of the architecture and technology.  It is the functional size estimate and not the delivery estimate</li>
<li>Architecture – What is the architecture and technology you want to use to deliver this solution</li>
<li>Delivery – Now deliver or consider delivering.

<ul>
<li>Estimate the delivery timeline and costs, and decide if the solution is worth doing.  If not, change architecture or change solution.</li>
<li>If this is a waterfall, deliver once.  If incremental, deliver in increments.</li>
</ul>
</li>
</ul>


<p>And bonus pieces</p>

<ul>
<li>Over – Now the project is either done or the process starts over until the solution solves the real problem.

<ul>
<li>This requires "Delta" size estimation.  How much is being added to or modified about a system?</li>
</ul>
</li>
<li>Review – Review the size of what was built (not time, but solution functional size)

<ul>
<li>Determine what you would likely want to improve in the solution, architecture, or delivery</li>
</ul>
</li>
</ul>


<p>So now that we have Esitmation</p>

<h3>Estimation of Solution Size</h3>

<p>The hard part is doing Estimation of Solution Size without getting pulled into the details of architecture and delivery.  We are not
yet good at this as an industry.  We need a body of knowledge and a system to estimate the size of a solution
 independent of the architecture chosen and the team that delivers.  If we have this, we can finally <em>measure</em>
 something useful.  Actually we can measure <em>a lot</em> of useful things.</p>

<ul>
<li>What is the ROI of the solution?  If the solution is really big, there are very few architectures and delivery teams that are going to dramatically reduce the cost</li>
<li>How well do certain architectures do against a particular solution?  For a given delivery team, you can see what they are good at or not.  Going across delivery teams, you may be able to identify <em>better</em> architectures vs. <em>more familiar</em> to the team.

<ul>
<li>What are the differences between the architectures that cause these effects?</li>
<li>Should we change architectures or train more in an architecture?</li>
</ul>
</li>
<li>How well do the delivery teams deliver?  Especially if the solution is about the same size, and the architecture is the same, you should start seeing better and worse results.

<ul>
<li>What are the differences between the teams that cause this effect?</li>
<li>Can we improve the numbers?</li>
</ul>
</li>
</ul>


<p>Estimation of solution size has been attempted with Function Points and more recently with COSMIC Function Points. I
think using the term "point" is not quite right, so I am going to recommend being more creative although just a
simple twist on the word.  I propose 'joint' to capture complexity.  Things with more joints are usually more
complex, and it is relatively linear or even somewhat exponential as you increase the joint count.</p>

<h3>Joints / Moves / COSMIC</h3>

<p>So what should constitute a 'joint'?  With very little effort in evaluating it (will be starting soon), I believe COSMIC
is a valid starting methodology.  So a COSMIC Point is a Joint.  Not much difference, but at least it splits the
  two issues: How big is it (1000 joints)?  How long is it expected to take to build it (10,000 points)?
  Given COSMIC measure data movements, a joint could be a synonym for a 'move', but if we augment the system with
  additions beyond 'moves' as source of size, then the term would become a misnomer.</p>

<p>More information about COSMIC is here: <a href="http://cosmic-sizing.org/">http://cosmic-sizing.org/</a> and elsewhere online.</p>

<h3>Analysis and Design</h3>

<p>When working through COSMIC terminology and examples, it flashed me back a couple decades to a time that we built software very differently:</p>

<ul>
<li>Software was built from requirements through analysis through design and then into implementation</li>
</ul>


<p>This was called a 'Waterfall' model because each stage tended to block doing anything for the next stage until
the stage was 'complete'.  Modern Agile proponents, especially the extremely agile, have basically dropped the stages.
But the stages are useful going both <em>forward</em> (analyse what your system is supposed to do before coding it) and <em>backward</em>
does the analysis seem to plausibly match the requirements?  The analysis and design work was actually not the problem,
it was just the amount of work (if you an analyst, you want to analyze) and the 'blocking' nature of the work that was
a problem.</p>

<p>A great book on this analysis and designe work was Object-Oriented Analysis and Design (1st edition) which was in several different programming
 languages and dealt with realtime, server application, and other types of software systems.  The second generation can
  be found here: <a href="http://www.sphoorthyengg.com/MCAupload/upload/object-oriented-analysis-and-design-with-applications-2nd-edition.pdf">http://www.sphoorthyengg.com/MCAupload/upload/object-oriented-analysis-and-design-with-applications-2nd-edition.pdf</a>
These methods became parts of UML, which is  again commonly used for <em>heavy</em> analysis and <em>heavy</em> design, preventing the
customer from seeing the actual product early on.</p>

<p>The solution isn't to drop the steps, but to scale and time them properly</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADD Stack [Part-9]]]></title>
    <link href="http://markfussell.emenar.com/blog/addstack-9/"/>
    <updated>2015-10-21T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/addstack-9</id>
    <content type="html"><![CDATA[<p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with 'Testing'.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.  The seventh went into logging, analytics, and monitoring of the running applications and nodes.
The eighth was an overview of Federation Components like caches, queues, payment services, and the like.</p>

<h2>Workers!</h2>

<p>Among the more interesting federation / deployment component are workers.  Workers are interesting because
they can do almost anything imaginable and they do it very efficiently.  How efficiently?  Well, the perfect
worker is at 100% when doing a task and <em>dead</em> when they have no tasks to do.  That is pretty darn efficient
because it approaches 100% and is only not 100% when we choose to not accept the 'spin up' latency of getting
 a new worker.  As the amount of work increases, our pool of workers increase, and the spin-up-latency decreases
 on a per-chore basis.  That is <em>very cool</em>: as scale goes up, efficiency <em>increases</em>.  There are a lot of places that
 is not true for computers, so it is nice when it is.</p>

<h3>Work?  Chore?</h3>

<p>So we want to have a worker model where we can add a 'chore' (a unit of work, using a term not otherwise used in
IT and CS... job, task, etc. are now ambivalent) to a queue of work-to-be-done, and have
 something do that chore.  There are a lot of ways to do this:</p>

<p> <!--more--></p>

<ol>
<li>Use BeanStalk</li>
<li>Use Kafka with a bunch of consumers</li>
<li>Use a database and launch a worker if none is available</li>
<li>Use Quartz and coordinate amongst the application servers which one is going to do the work</li>
<li>Use GitHub and launch one or more workers as needed</li>
</ol>


<p>And that is just a minor collection of simple solutions.  The first two are probably 'the best' in terms of having
a very clean model.  But they require additional infrastructure and I am trying to keep that at a minimum.  The
second is using a database as a WorkQueue.  Well, it turns out that this is actually commonly done and almost
always <em>regretted</em>.  Most databases are horrible with the characteristics of Chores and their lifecycle.  So it does
work, but not well.</p>

<p>The fourth is quite functional but not scalable.  You don't want your application servers doing <em>a lot</em> of work.
A little housekeeping is fine.  But the whole point of the Worker model is to enable as many or as few workers who each
<em>always</em> do <em>a lot</em> of work.  And then go away if no longer needed.  That isn't the lifecycle and duty of application
servers.</p>

<p>So if you haven't guessed by now, I am going to describe the fifth approach.  Use an annexed Git repository to describe
chores, their media (if any), and to provide the results (if any).  It turns out to be blazingly fast, scalable,
and flexible.  A little weird but sometimes weird really works.</p>

<h3>Chores, Parents, and Workers</h3>

<p>A lot of time, the real world can seriously inspire the computer world.  The Worker model I am about to describe
matches a 'high-speed', 'high-efficiency', parenting model.  I would guess any parent can see the similarities
and even the Nirvana of this Worker model.  It has a few major components:</p>

<ul>
<li>The World creates some Chores in a to-do list</li>
<li>The World doesn't want to do the Chores, because it has other things to do</li>
<li>So The World creates two or more adults (for redundancy) so they can do the Chores

<ul>
<li>And then The World gives responsibility to the adults to do the Chores</li>
</ul>
</li>
<li>The adults don't want to actually do the Chores themselves, so they produce Workers to do the Chores</li>
<li>The Workers are so awesome that they automatically <em>all</em> try to do the Chores, as quickly as possible

<ul>
<li>The adults (Parents) have worked out a system to prevent two Workers from doing the same Chore</li>
</ul>
</li>
<li>If the Chores are not getting done fast enough, the Parents produce more Workers</li>
<li>If there is no more work to do, the Workers go to sleep

<ul>
<li>Waking periodically to see if there is more work</li>
<li>Or if the Chores are not getting done fast enough, the Parents wake one or more Workers</li>
</ul>
</li>
</ul>


<p>With this model:</p>

<ul>
<li>The World is the Application Server or something similar</li>
<li>The Parents are special Nodes (or processes on Application Server nodes) that can see the 'to-do' list</li>
<li>The Workers are special Nodes that are created as the 'to-do' list backlog gets larger</li>
</ul>


<p>You need at least two Parents at all time to make sure the To-Do list is being watched.  You don't need any
Workers until the To-Do list is sufficiently long or latent.</p>

<p>We will put the 'To-Do' chores into a specially structured, annexed, Git repository.  Because of the annexing,
resources are automatically 'deduped' and having each 'chore' be self-contained is both possible and space
efficient.  Imagine all the 'jar's needed for a java build.  Given most of these are stable between builds,
they cost nothing at all to include in a 'chore'.  Where people run fragile artifact servers (fragile because
(a) they exist as something that could fail and (b) they are rarely run redundantly) that have to handle
heavy load, the Annex puts all that load on S3... which is designed from the ground-up for loads well beyond our workers.</p>

<h4>Chore Structure</h4>

<p>The core of a Chore has to include:</p>

<ul>
<li>The identity of the chore

<ul>
<li>And an ability to 'take it on'</li>
</ul>
</li>
<li>What the instructions are for the chore</li>
<li>What resources you need for the chore</li>
<li>Where the results of the chore are supposed to go</li>
</ul>


<p>To make the throughput easier to see, we will organize chores by time.  So basically a queue.  We can have 'priority' within the
metadata of the chore if we want things to jump the queue.  And we can have different chore types (or IT needs) to
make sure a worker can really handle the chore. Using the 'cron_1m' model of things working on the minute, we will
put things into buckets every minute.  But workers have to look for any not-done chore and pick it up if they can.</p>

<p>An advantage of the one-minute cron is we automatically can have a nice 30-second jitter.  That plus some kind of randomization
in chore selection makes it very unlikely that workers will acquire the same chore at the same time.  But if they do, one will win due
to 'git push' timing.</p>

<h5>Identity</h5>

<p>Chores are identified by their 'producer' and a timestamp.  A 'producer' is a node plus a process id, and the timestamp can
have any precision necessary for the process to know it can't collide with itself.  Two of the banes of any identity system
is making sure identity is unique and not having a bottleneck for identity generation.  The identity proposed solves these
two main issues.  A third requirement (sometimes) is keeping identity short / consistent.  A hash of the 'phrase' is
possible if necessary, but collisions could be an issue if the phrase is too short.</p>

<h5>Instructions</h5>

<p>So we have something like "chore_ip-1-2-3-4_ps-349467_20151022-110109-123456" as a chore.  This is simply a directory with
a 'chore.json' within it where that 'chore.json' looks something like this:</p>

<p><code>json
{
  "chore_id" : "ip-1-2-3-4_ps-349467_20151022-110109-123456",
  "chore_tss" : "20151022110109",
  "producer_id" : "ip-1-2-3-4_ps-349467",
  "runner" : "bash",
  "command" : "ps -aux",
  "result" : "output.txt",
  "error" : "error.txt"
}
</code></p>

<p>Another file is in the directory initially called 'do_it.txt' which can be empty.</p>

<h5>Take on the 'chore'</h5>

<p>To take this 'chore' on, a worker adds a 'worker.json' file to the directory:</p>

<p><code>json
{
  "chore_id" :  "ip-1-2-3-4_ps-349467_20151022-110109-123456",
  "work_id" :  "ip-4-5-6-7_ps-1000_20151022-110209-123456",
  "worker_id" : "ip-4-5-6-7_ps-1000",
  "work_start_tss" : "20151022110209",
  "state" : "working",
  "work_finish_tss" : ""
}
</code></p>

<p>and renames the 'do_it.txt' to 'doing_it.txt'</p>

<p>When these changes commit and push successfully, this worker now owns the chore.  The worker can update the 'worker.json'
through the work if desired, or put files into the directory or elsewhere.  When the chore is complete, the worker
should change worker.json to a finished state, and rename the 'doing_it.txt' to 'done.txt'.  With this,
the three states are:</p>

<ul>
<li>do_it.txt</li>
<li>doing_it.txt</li>
<li>done.txt</li>
</ul>


<p>And everyone can quickly tell what the state of a chore is without worrying about the details.  Or dive into the json
and results to figure out those details.</p>

<p>Visually it would look likte this:</p>

<p><img src="http://markfussell.emenar.com/images/addstack-9/addstack9_chore1.png" /></p>

<p><img src="http://markfussell.emenar.com/images/addstack-9/addstack9_chore2.png" /></p>

<p><img src="http://markfussell.emenar.com/images/addstack-9/addstack9_chore3.png" /></p>

<p>The script to acquire a chore is a little involved because of the possibility of failure, but basically it just</p>

<ul>
<li>Finds all the 'doit.txt' files</li>
<li>Picks one at random</li>
<li>Tries to rename it and push that change

<ul>
<li>If successful, then we are in.  If not, roll-back</li>
</ul>
</li>
</ul>


<p><code>``bash
export RANDOM_DO_IT=</code>find work -name 'do_it.txt' | while read x; do echo "`expr $RANDOM % 1000`:$x"; done | sort -n | sed 's/[0-9]*://' | head -1`</p>

<h1>...</h1>

<p>git mv $RANDOM_DO_IT "${RANDOM_DO_IT_DIR}/doing_it.txt"</p>

<h1>...</h1>

<p>git push
PUSH_RETVAL=$?</p>

<p>if [ $PUSH_RETVAL -ne 0 ];
then</p>

<h1>=================================================</h1>

<h1>=== We failed to acquire, so roll-back</h1>

<h1>=================================================</h1>

<p>```</p>

<h4>Doing the work</h4>

<p>A worker should alway be able to acquire:</p>

<ul>
<li>The root of the work repository – Say "${GIT_ROOT}"</li>
<li>The root of the chore itself – Say "${CHORE_ROOT}"</li>
</ul>


<p>Where the "GIT_ROOT" can have shared scripts in its 'work/bin' or 'bin' directories, and the chore can have
individual scripts in it CHORE_ROOT/bin directory.  We also likely have 'repo2' available,
so we have access to a lot of resources (common and work specific) to leverage.</p>

<h4>Saving the work</h4>

<p>When the worker is done, it needs to do a final 'write' of all the results.  This could be nothing more than
logs (a worker is 'anonymous' and ephemeral, so ideally logs go to the chore's directory vs. somewhere
effectively 'random').  This is just a final pull-push:</p>

<p>```bash</p>

<h1>=================================================</h1>

<h1>=== Done, try to write out the results</h1>

<h1>===</h1>

<h1>=== Make sure everything is annexed</h1>

<h1>=================================================</h1>

<p>./bin/deflatePaths.sh "${RANDOM_DO_IT_DIR}"</p>

<p>git pull</p>

<h1>...</h1>

<h1>=================================================</h1>

<h1>=== Pull successful, start writing</h1>

<h1>=================================================</h1>

<p>git mv "${RANDOM_DO_IT_DIR}/doing_it.txt" "${RANDOM_DO_IT_DIR}/done.txt"</p>

<p>git add -A "${RANDOM_DO_IT_DIR}/../"
git commit -m "$ME completed chore ${RANDOM_DOIT_DIR}"</p>

<p>git push
```</p>

<p>and as long as this is successful, the work is done.</p>

<h4>Jitter</h4>

<p>Although the randomization of chore selection helps with a lot of chores, it does not help when there are very few
chores left.  On the 'go' of chore selection, all the workers go after the chore.  So we need to say 'go' at
different times.  This brings back the 'jitter' concept mentioned previously.  To jitter in this case, we just
create a 'random' number and then modulo it by whatever jitter interval we want.</p>

<p>For example, using the process id plus the time stamp, and trying for a 0-29 range, we can have:</p>

<p><code>bash
TSS_SECOND=`date +%s`
PSEUDO_RANDOM="`expr ${TSS_SECOND} + $$`"
SLEEP_LENGTH=$((${PSEUDO_RANDOM} % 30 ))
</code></p>

<h2>Conclusion</h2>

<p>The above is a very generic worker model that enables all kinds of flexibility in setting up 'chores' and scalably
having a 'right-size' for the number of workers doing the work.  The next article will be more specific and
build new 'wars' every time the application changes after passing the built-in tests.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADD Stack [Part-8]]]></title>
    <link href="http://markfussell.emenar.com/blog/addstack-8/"/>
    <updated>2015-10-20T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/addstack-8</id>
    <content type="html"><![CDATA[<p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with 'Testing'.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.  The seventh went into logging, analytics, and monitoring of the running applications and nodes.</p>

<h2>Federation Application Infrastructure</h2>

<p>The application stack we have so far:</p>

<ul>
<li> UI (both client and server)</li>
<li> Application Server (Grails, Java, potentially scripting engine)</li>
<li> Database (Maria or similar)</li>
</ul>


<p>Is very capable.  Using it combined with the ADD ingredients:</p>

<ul>
<li> GitHub – With resource, presence, application, and configuration information repositories</li>
<li> EC2 Instances – Running continuously or based on load, and running their 'part' plus any dynamic configuration</li>
<li> S3 – For resources</li>
<li> HipChat – To let everyone know</li>
</ul>


<p>Makes for a very functional application.  The nodes and their applications can talk to each other based on presence.
The nodes and their application can keep certain data in-memory (cached).  The nodes can
 launch other nodes to handle load or do certain tasks.  An Application Server is a very generic thing and
 can do pretty much anything.</p>

<h3>Standard Federation Components</h3>

<p>Doing pretty much anything and everything turns out to be very confusing.  For people.  Big monoliths of capabilities
are basically beyond comprehension.  And the bigger the monolith, the harder it falls.  The more likely it falls.
And even if you have redundant monoliths, the system becomes very painful to maintain and to learn.</p>

<!--more-->


<p>So instead of having the one super-capable application server, we can start breaking out some of the responsibilities
of the application server into other system components, and then decide whether we need them or not.  If we need
them, we will be using a very main-stream approach that is redundant, scalable, and easily managed.  It needs to 'fit'
with our application, but it doesn't have to be similar to the application (e.g. works with Java, written in Erlang,
runs on Linux).</p>

<p>The list of standard system components isn't that long, but it is <em>longer than you need</em>.  If you are using all of these,
you are likely over-engineering your solution.  Try to start weaning yourself off some of this technology.</p>

<p>A partial list of federation components</p>

<ul>
<li>Cache – For rapidly retrieving information that changes slowly or needs to be shared broadly</li>
<li>Queue – For getting information from producers (requests) to consumers (workers)</li>
<li>Distributed State – For precise and consistent decision-making among several different entities</li>
<li>Semistructured Database – For persistently storing data in a faster or more flexible format than the main database</li>
<li>SSO (Single Sign-on) – To enable users to get access to various resources without the resources having to authenticate</li>
<li>"Chat" – Real-time presence and data communication enabling 'chat' and various other capabilities</li>
<li>Map-Reduce – Taking large amounts of data and processing it to get answers to questions.  Can be real-time or not</li>
<li>Forum – Supporting forum capabilities for customers to talk with each other</li>
<li>Customer Support – Supporting customer-facing capabilities, including defect and product request tracking</li>
<li>SMS / Email / Contact – Ability to send out emails, SMS, surveys, and other customer contact</li>
<li>Web Site – A separate web site from the main application</li>
<li>Web Content Creator – An ability to enable users to create content within your site (vs. doing it via templating)</li>
<li>Payment Processing – Handling the record of credit cards and payment processing</li>
<li>Freetext Search – The ability to search documents and similar free text</li>
<li>Workers – Special nodes that do work and either go idle or disappear when no work is needed</li>
</ul>


<p>There are some more (e.g. the BI pipeline), but that is a pretty good list.  Especially the 'Workers' is a category basically as broad as
'Application'.</p>

<p>Working through the list, here are some examples:</p>

<ul>
<li>Cache – Redis <a href="http://redis.io">http://redis.io</a></li>
<li>Queue – Kafka <a href="http://kafka.apache.org">http://kafka.apache.org</a></li>
<li>Distributed State - Presence in Git (for minutes), ZooKeeper (for sub-second) <a href="http://zookeeper.apache.org">http://zookeeper.apache.org</a> and Curator <a href="http://curator.apache.org/curator-recipes/index.html">http://curator.apache.org/curator-recipes/index.html</a></li>
<li>Semistructured Database – Riak  <a href="http://basho.com/products/">http://basho.com/products/</a></li>
<li>SSO – Shibboleth <a href="http://shibboleth.net">http://shibboleth.net</a></li>
<li>Chat – Ejabberd <a href="https://www.ejabberd.im">https://www.ejabberd.im</a></li>
<li>Map-Reduce – Spark <a href="https://spark.apache.org">https://spark.apache.org</a>,  Hadoop <a href="https://hadoop.apache.org">https://hadoop.apache.org</a></li>
<li>Forum –  phpBB <a href="https://www.phpbb.com">https://www.phpbb.com</a></li>
<li>Customer Support – Parature <a href="http://www.parature.com">http://www.parature.com</a></li>
<li>SMS / Email / Contact – SendGrid <a href="https://sendgrid.com">https://sendgrid.com</a> , Silverpop <a href="http://www-03.ibm.com/software/products/en/silverpop-engage">http://www-03.ibm.com/software/products/en/silverpop-engage</a> , SurveyMonkey <a href="https://www.surveymonkey.com">https://www.surveymonkey.com</a> , etc.</li>
<li>Web Site –  Expression Engine <a href="https://ellislab.com/expressionengine">https://ellislab.com/expressionengine</a> , Squarespace <a href="http://www.squarespace.com">http://www.squarespace.com</a></li>
<li>Web Content Creator – How about the original 'wiki' <a href="http://wiki.org">http://wiki.org</a> or a more modern one like Foswiki <a href="http://foswiki.org">http://foswiki.org</a></li>
<li>Payment Processing – PayPal <a href="http://paypal.com">http://paypal.com</a> or even Facebook <a href="http://facebook.com">http://facebook.com</a> and Google <a href="http://google.com">http://google.com</a></li>
<li>Freetext Search – Solr <a href="http://lucene.apache.org/solr/">http://lucene.apache.org/solr/</a></li>
<li>Workers – All kinds of workers and frameworks for doing it, including AWS beanstalks <a href="http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features-managing-env-tiers.html">http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features-managing-env-tiers.html</a></li>
</ul>


<p>Sadly, Rumble did use almost all of the above (and more) in some way or another, but that is seriously off-the-chart
and incredibly expensive.  Yes, it is powerful.  No, your users do not care to pay you for that much power.</p>

<p>A company like Wikipedia/Wikimedia looks more like this:</p>

<p><img src="http://markfussell.emenar.com/images/addstack-8/addstack8_wikimedia1.png" /></p>

<h2>Conclusion</h2>

<p>It is good to understand what kinds of system components are out there and be aware that you don't have to
reinvent / recode them when you need them.  Each of the above are good products.  They do what they should
to fill a particular need.  And almost all of them are
fault-tolerant and scalable, so they can join the rest of the <em>very tolerant</em> ADD stack.
Or they are a service and you get what you pay for.  If you really need
one of them, certainly bring it aboard.  It is better than creating a monolith.
But if you can do without it, your application and you IT will be easier to understand and maintain.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADD Stack [Part-7]]]></title>
    <link href="http://markfussell.emenar.com/blog/addstack-7/"/>
    <updated>2015-10-19T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/addstack-7</id>
    <content type="html"><![CDATA[<p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with 'Testing'.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.</p>

<h2>Logging, Analytics, and Monitoring</h2>

<p>Returning to a bit more of an 'IT' issue, how do we handle logging, monitoring, and analytics on our collection of
machines?  There are a number of choices:</p>

<ol>
<li>Run our own infrastructure</li>
<li>Go with an inexpensive provider</li>
<li>Go with a more capable provider</li>
<li>Don't</li>
</ol>


<p>Of the above, I believe #3 is usually worth it until your scale gets to the point of needing #1.  Downgrading
from #3 to #2 is fine <em>after</em> you have learned the capabilities you are giving up.</p>

<!--more-->


<h3>Logging: SumoLogic</h3>

<p>The longest standing, very successful, and SaaS capable company is Splunk (<a href="http://splunk.com/">http://splunk.com/</a>) .  But their prices are crazy.  Have no
idea how they can charge that much.  So instead I will demo SumoLogic (<a href="http://SumoLogic.com/">http://SumoLogic.com/</a>) as the '3B' tier.</p>

<p>Installing SumoLogic is incredibly easy:</p>

<p><code>bash
wget "https://collectors.us2.sumologic.com/rest/download/linux/64" -O SumoCollector.sh &amp;&amp; chmod +x SumoCollector.sh &amp;&amp; ./SumoCollector.sh -q -VskipDefaultSources=true -Vsumo.token_and_url={token}
</code></p>

<p>And the collector is on the machine.  If you tell it what you want to aggregate, it starts collecting and indexing files in those paths.  In our case, the nodes
all have files in '/root/log' which it would be nice to have aggregated.</p>

<p>The results are visible here:</p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_sumo1.png" /></p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_sumo2.png" /></p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_sumo3.png" /></p>

<h4>Logging Alternative: Graylog</h4>

<p>For Rumble, we had a Graylog (<a href="http://graylog.com/">http://graylog.com/</a>) cluster that dealt with a tremendous amount of data (half a
terabyte a day if memory serves, due to over-enthusiastic logging) and was relatively stable under that load.
Elasticsearch had issues if a node failed (just due to the stress of moving data to another backup), but this
is under pretty extreme load levels.  So if you wanted to roll your own, the Graylog path would be a very
inexpensive and powerful path.</p>

<h3>Analytics and Monitoring: NewRelic</h3>

<p>NewRelic (<a href="http://newrelic.com/">http://newrelic.com/</a>) started out as a Ruby-oriented monitoring service, and basically came about because Ruby/Rails developers
(a) wanted a lot of information about why their apps were running slowly, (b) had very little knowledge about
operations and other ways of monitoring things, and (c) Ruby itself has little support for monitoring.  NewRelic
came along and provided the metrics (as you would expect for Java and similar mature languages) <em>outside</em> the
Ruby environment.  Initially this could be viewed as a crutch for Ruby where Java didn't need it, but ultimately
by putting the metrics outside the application everyone's life was simpler.</p>

<p>To install NewRelic, you need to get the agent onto the machine.  In our case we are going to leverage the annex:</p>

<p>```bash</p>

<h1>====================================================</h1>

<h1>=== Install NewRelic</h1>

<h1>====================================================</h1>

<h1>===================================</h1>

<h1>=== Server</h1>

<h1>===================================</h1>

<p>rpm -Uvh http://download.newrelic.com/pub/newrelic/el5/i386/newrelic-repo-5-3.noarch.rpm
yes | yum -y install newrelic-sysmond
nrsysmond-config --set license_key=key</p>

<p>/etc/init.d/newrelic-sysmond start</p>

<h1>===================================</h1>

<h1>=== Java</h1>

<h1>===================================</h1>

<p>export APP_VERSION=3.21.0
export APP_FULL_VERSION=newrelic-java-${APP_VERSION}</p>

<p>mkdir -p .temp
cp it/resource/${APP_FULL_VERSION}.zip .temp/</p>

<p>./bin/inflatePaths.sh .temp/${APP_FULL_VERSION}.zip</p>

<p>mkdir -p /opt
cp -fr .temp/newrelic /opt/</p>

<p>cp -fr ${RESOURCE}/newrelic.yml /opt/newrelic/newrelic.yml</p>

<p>```</p>

<p>The first section puts on the system-monitoring agent for newrelic.
The second section has two parts.  The first part puts the general NewRelic agent onto the machine, and the second part
enables us to override (overlay) the default configuration with our own.  The most important part is to replace the
license, but there are many things that can be configured within the NewRelic agent.</p>

<p>Finally, we need to launch with the agent configuration into the java / 'gradew' launcher:</p>

<p>```bash</p>

<h1>Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.</h1>

<p>DEFAULT_JVM_OPTS="-javaagent:/opt/newrelic/newrelic.jar"
```</p>

<p>After doing this and waiting for the metrics to hit the NewRelic servers, we get some nice visuals:</p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic2.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic4.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic5.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic6.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic7.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic7.png" /></p>

<h3>Operational Monitoring: Nagios and Icinga</h3>

<p>The above monitoring is not 'alert' oriented.  It lets you drill into the details of what is happening
in operations both currently and somewhat into the past.  To be a bit more alert oriented, you need
to go down a different path.  The most mature open source path is the Nagios / Icinga double path (<a href="http://nagios.org/">http://nagios.org/</a>,
 <a href="http://icinga.org/">http://icinga.org/</a>).</p>

<p>An important aspect of monitoring is to have <em>multiple</em> monitors on your network.  And, in general, for the monitors
to be outside the data center.  Agents within the data center can relay information out, but if your monitors fail
inside the data center, you are (unknowingly) blind.</p>

<p>So for Nagios, we can demonstrate monitoring from the developers (or operations dashboard) machine vs.
within the data center.  Because of the presence being visible from anywhere, monitoring configuration can happen
anywhere that you can pull out a git repository.</p>

<p>Examples of Nagios views are:</p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_nagios1.png" /></p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_nagios2.png" /></p>

<p>Where the lists of hosts to monitor and what to monitor comes from text configuration files.</p>

<p><code>
define host {
   host_name   {host_name}
   use         {node_type}
   alias       {node_id}
   address     {node_public_address}
   register    {registration_order}
}
</code></p>

<p>And these files can trivially be generated from the presence information, and updated if
anything changes.  An important aspect is to make sure to turn off the monitoring system
when a node is going down <em>intentionally</em>.  So the 'node_state' status and 'node_app_state'
status are critical to have come through the presence information for monitoring to
not be 'noisy'.  A noisy monitor is a monitor that will quickly be forever ignored.</p>

<p>Although Nagios and Icinga have dashboards, everything should go into HipChat so everyone
can see the history and stability/instability of the system.  You can even publish the status
  publicly so your users will know there is a production problem. If you enable public chat
  in either HipChat or elsewhere, the users can both see the status and ask for predictions
  of when issues are resolved.  A much higher-touch relationship with users can make them
  longer users (this retention aspect was very true of Winster where the CEO was <em>online</em>
  and could be chatted with a good portion of the evening.  Kind of like walking the floors
  of the casino or Tim Cook being in the University Apple Store.).</p>

<h2>Conclusion</h2>

<p>Although it is more operational than "application stack", the ability to monitor and analyze your
application's performance and behavior is critical to any production deployment of it.  So you
should think about it early and not as an afterthought.  All logging should go into the logging pipeline
(no System.println or equivalent) and be searchable through that pipeline at one or more aggregators.
Start out with a metrics system like NewRelic to get a bunch  of valuable things for free
and you can later add in new application-specific metrics.
And get the basics of operational monitoring up early and you will know if the application and the
IT is reliable long before it gets into the production data center.</p>
]]></content>
  </entry>
  
</feed>
