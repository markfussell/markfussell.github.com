<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cloud | Polyglot]]></title>
  <link href="http://markfussell.emenar.com/blog/categories/cloud/atom.xml" rel="self"/>
  <link href="http://markfussell.emenar.com/"/>
  <updated>2015-10-20T09:56:38-07:00</updated>
  <id>http://markfussell.emenar.com/</id>
  <author>
    <name><![CDATA[Mark Fussell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ADD Stack [Part-7]]]></title>
    <link href="http://markfussell.emenar.com/blog/addstack-7/"/>
    <updated>2015-10-19T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/addstack-7</id>
    <content type="html"><![CDATA[<p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with 'Testing'.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting. The sixth discussed UI frameworks in a bit more detail and ended with an Angular vs.
Ember as a core choice.</p>

<h2>Logging, Analytics, and Monitoring</h2>

<p>Returning to a bit more of an 'IT' issue, how do we handle logging, monitoring, and analytics on our collection of
machines?  There are a number of choices:</p>

<ol>
<li>Run our own infrastructure</li>
<li>Go with an inexpensive provider</li>
<li>Go with a more capable provider</li>
<li>Don't</li>
</ol>


<p>Of the above, I believe #3 is usually worth it until your scale gets to the point of needing #1.  Downgrading
from #3 to #2 is fine <em>after</em> you have learned the capabilities you are giving up.</p>

<!--more-->


<h3>Logging: SumoLogic</h3>

<p>The longest standing, very successful, and SaaS capable company is Splunk (<a href="http://splunk.com/">http://splunk.com/</a>) .  But their prices are crazy.  Have no
idea how they can charge that much.  So instead I will demo SumoLogic (<a href="http://SumoLogic.com/">http://SumoLogic.com/</a>) as the '3B' tier.</p>

<p>Installing SumoLogic is incredibly easy:</p>

<p><code>bash
wget "https://collectors.us2.sumologic.com/rest/download/linux/64" -O SumoCollector.sh &amp;&amp; chmod +x SumoCollector.sh &amp;&amp; ./SumoCollector.sh -q -VskipDefaultSources=true -Vsumo.token_and_url={token}
</code></p>

<p>And the collector is on the machine.  If you tell it what you want to aggregate, it starts collecting and indexing files in those paths.  In our case, the nodes
all have files in '/root/log' which it would be nice to have aggregated.</p>

<p>The results are visible here:</p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_sumo1.png" /></p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_sumo2.png" /></p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_sumo3.png" /></p>

<h4>Logging Alternative: Graylog</h4>

<p>For Rumble, we had a Graylog (<a href="http://graylog.com/">http://graylog.com/</a>) cluster that dealt with a tremendous amount of data (half a
terabyte a day if memory serves, due to over-enthusiastic logging) and was relatively stable under that load.
Elasticsearch had issues if a node failed (just due to the stress of moving data to another backup), but this
is under pretty extreme load levels.  So if you wanted to roll your own, the Graylog path would be a very
inexpensive and powerful path.</p>

<h3>Analytics and Monitoring: NewRelic</h3>

<p>NewRelic (<a href="http://newrelic.com/">http://newrelic.com/</a>) started out as a Ruby-oriented monitoring service, and basically came about because Ruby/Rails developers
(a) wanted a lot of information about why their apps were running slowly, (b) had very little knowledge about
operations and other ways of monitoring things, and (c) Ruby itself has little support for monitoring.  NewRelic
came along and provided the metrics (as you would expect for Java and similar mature languages) <em>outside</em> the
Ruby environment.  Initially this could be viewed as a crutch for Ruby where Java didn't need it, but ultimately
by putting the metrics outside the application everyone's life was simpler.</p>

<p>To install NewRelic, you need to get the agent onto the machine.  In our case we are going to leverage the annex:</p>

<p>```bash</p>

<h1>====================================================</h1>

<h1>=== Install NewRelic</h1>

<h1>====================================================</h1>

<h1>===================================</h1>

<h1>=== Server</h1>

<h1>===================================</h1>

<p>rpm -Uvh http://download.newrelic.com/pub/newrelic/el5/i386/newrelic-repo-5-3.noarch.rpm
yes | yum -y install newrelic-sysmond
nrsysmond-config --set license_key=key</p>

<p>/etc/init.d/newrelic-sysmond start</p>

<h1>===================================</h1>

<h1>=== Java</h1>

<h1>===================================</h1>

<p>export APP_VERSION=3.21.0
export APP_FULL_VERSION=newrelic-java-${APP_VERSION}</p>

<p>mkdir -p .temp
cp it/resource/${APP_FULL_VERSION}.zip .temp/</p>

<p>./bin/inflatePaths.sh .temp/${APP_FULL_VERSION}.zip</p>

<p>mkdir -p /opt
cp -fr .temp/newrelic /opt/</p>

<p>cp -fr ${RESOURCE}/newrelic.yml /opt/newrelic/newrelic.yml</p>

<p>```</p>

<p>The first section puts on the system-monitoring agent for newrelic.
The second section has two parts.  The first part puts the general NewRelic agent onto the machine, and the second part
enables us to override (overlay) the default configuration with our own.  The most important part is to replace the
license, but there are many things that can be configured within the NewRelic agent.</p>

<p>Finally, we need to launch with the agent configuration into the java / 'gradew' launcher:</p>

<p>```bash</p>

<h1>Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.</h1>

<p>DEFAULT_JVM_OPTS="-javaagent:/opt/newrelic/newrelic.jar"
```</p>

<p>After doing this and waiting for the metrics to hit the NewRelic servers, we get some nice visuals:</p>

<p><img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic1.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic2.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic3.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic4.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic5.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic6.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic7.png" />
<img src="http://markfussell.emenar.com/images/addstack-7/addstack7_newrelic7.png" /></p>

<h3>Operational Monitoring: Icinga</h3>

<p>The above monitoring is not 'alert' oriented.  It lets you drill into the details of what is happening
in operations both currently and somewhat into the past.  To be a bit more alert oriented, you need
to go down a different path.  The most mature open source path is the Nagios / Icinga double path (<a href="http://nagios.org/">http://nagios.org/</a>,
 <a href="http://icinga.org/">http://icinga.org/</a>).</p>

<p>An important aspect of monitoring is to have <em>multiple</em> monitors on your network.  And, in general, for the monitors
to be outside the data center.  Agents within the data center can relay information out, but if your monitors fail
inside the data center, you are (unknowingly) blind.</p>

<p>So for Nagios, we can demonstrate monitoring from the developers (or operations dashboard) machine vs.
within the data center.  Because of the presence being visible from anywhere, monitoring configuration can happen
anywhere that you can pull out a git repository.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADD Stack [Part-6]]]></title>
    <link href="http://markfussell.emenar.com/blog/addstack-6/"/>
    <updated>2015-10-17T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/addstack-6</id>
    <content type="html"><![CDATA[<p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with 'Testing'.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.  The fifth added some major aspects to the stack: Semi-Structured Data, Templates,
and Dual or Isomorphic scripting.</p>

<h2>Which UI framework?</h2>

<p>The fourth article discussed UI alternatives, but they were mostly 'architectural' alternatives and did not
specify a particular framework to use.  I believe that is correct in that <em>how you use</em> the framework can be more
important than the framework itself.  People can correctly and badly use all kinds of different technology.
Use a hammer correctly and you might have a slight penalty (rubber vs. metal) if it is a bit weaker of a tool, but
use it wrong (have thumb be accessible) and you can be seriously hurt.</p>

<p>There are a number of popular frameworks:</p>

<ul>
<li>Angular</li>
<li>Ember</li>
<li>Backbone</li>
<li>Sencha</li>
<li>etc.</li>
</ul>


<p>And deciding between them may seem like "which has the best features?" but unless something has a killer feature
(Sencha can run the same code on the desktop and mobile) that you care about, and is worth its penalties (Sencha
is proprietary and very 'different') then 'best features' is basically meaningless.  A better question is "Which
one do I understand the best?" and "Which one can other people learn and share-code the best?".</p>

<!--more-->


<p>Taking out 'Sencha' from the above and you get a few different viewpoints on the web:</p>

<ul>
<li>&lt;http://blog.yodersolutions.com/why-i-recommend-emberjs-over-angularjs/ ></li>
<li><a href="https://www.airpair.com/js/javascript-framework-comparison">https://www.airpair.com/js/javascript-framework-comparison</a></li>
<li><a href="https://www.quora.com/Is-Angular-js-or-Ember-js-the-better-choice-for-JavaScript-frameworks">https://www.quora.com/Is-Angular-js-or-Ember-js-the-better-choice-for-JavaScript-frameworks</a></li>
</ul>


<p>And dropping Backbone, the distinction is really:</p>

<ul>
<li>Angular – Powerful, dry, and scale-limited framework</li>
<li>Ember – Less dry, more opinionated, and more scalable</li>
</ul>


<p>With Angular you have the ability to shoot yourself more and get confused more.  With Ember you will likely
have to be more explicit, but the convention and the explicitness should make the code more readable and
maintainable.</p>

<p>Angular is so similar to Flex that it is very intuitive to me (even directives), but I have seen it used
in ways I think the Angular team would be shocked by.  Sencha is confusing but is so mature, documented,
and powerfully-fragile (do something wrong and you get a terribly visible break) that you can't really use it wrong.
Ember appears to have the advantages of Rails and Grails... as the framework innately 'works' you can't
really deviate very much.  Also, Ember causes certain ripples (handlebars vs. dust) so you need to
decide early whether you want complete alignment</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADD Stack [Part-5]]]></title>
    <link href="http://markfussell.emenar.com/blog/addstack-5/"/>
    <updated>2015-10-16T01:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/addstack-5</id>
    <content type="html"><![CDATA[<p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with 'Testing'.  The third dealt with the application stack (Grails and other technologies).
The fourth discussed UI alternatives.</p>

<p>This article is about some fairly advanced capabilities, but capabilities that many projects find useful,
and so should be considered within the context of the overall context.  They are:</p>

<ul>
<li> Data Flexibility and Templating</li>
<li> Server Side Scripting</li>
</ul>


<h2>Data Flexibility and Template Systems</h2>

<p>One of the more interesting capability of an application is when users can control the content and presentation
of information.  Content is relatively easy given pure structured information is trivial to store in most
any database.  As the content becomes more unstructured you need to shift models and store it in a 'meta'
structure like JSON.  As the content becomes bigger, you need the flexibility of very large objects (BLOBs and CLOBs)
stored either in the database or potentially within content repositories like S3.  Using the Annex model
discussed earlier, you can simply store a hash in the database and the actual content on S3, and then
<em>the client</em> can pull down the information without taxing your server network at all.</p>

<p>Having flexible data is not very useful unless you can present it.  If the data is in JSON, you need to
be able to take JSON and render it into text, HTML, or something the programming language can work with.
There are a number of template systems out there:</p>

<ul>
<li> Mustache</li>
<li> Jade</li>
<li> Dust</li>
</ul>


<!--more-->


<p>Deciding amongst them depends on who is going to be writing the template and 'where' it is
going to execute.  But I recommend (a) making it language agnostic, (b) making it output agnostic,
and (c) making writing HTML templates a lot like writing HTML (and not something weird even if "more
powerful").  I have seen a lot of developers argue that you should write HTML in some YAML like language.
That is like saying you should write Java in some LISP-like language.  It makes no sense to change
syntax that dramatically even if every language is computationally equivalent.  HTML is verbose
because people like that lack of ambiguity (The original SGML was much more ambiguous and powerful).
There are plenty of auto-complete tools out there that help with HTML.  And everyone can follow
'fragments' of HTML better because the fragment has so much redundant information.</p>

<p>Among the above, it seems that Dust <a href="http://dustjs.com/">http://dustjs.com/</a> is a well supported successor to Mustache / Handlebars.
Besides having LinkedIn support, it appears the company <a href="http://cloudcms.com/">http://cloudcms.com/</a> is using it as well.  There is
a comparison of frameworks at <a href="https://engineering.linkedin.com/frontend/client-side-templating-throwdown-mustache-handlebars-dustjs-and-more">Templating Throwdown</a></p>

<p>By combining an ability to retrieve arbitrary information with arbitrary templates, we can enable
a user to generate any page they want... either for themselves or for other people.</p>

<h3>Scary!</h3>

<p>OK, the above should seem both epic and <em>scary</em>.  A user can generate arbitrary HTML pages
including JavaScript?  Doesn't that mean they could do <em>anything</em> including hijack another user?  Get
their password?  Stuff like that?</p>

<p>If you do it wrong... yes... yes they can.  Fortunately we have Facebook, MySpace and other companies that
show how to do it wrong and then fix the problem.  The general solution is:</p>

<ul>
<li>Users never authenticate with 'The Page'.  They only authenticate with you.</li>
<li>You give the page a valid one-time token for that third party to contact you on behalf of a user</li>
<li>You make sure to verify the token before doing anything for the user, and only allow the page / third party to do things you (or the user) approve</li>
</ul>


<p>This model makes sure the third party is not doing anything dangerous to your site...
or at least not successfully doing anything.</p>

<h2>Server-Side Scripting</h2>

<p>Along with the data flexibility combined with templating described above, there is an even scarier and more powerful
option to enable within-server scripting.  This ability to have code be mutable at run-time enables some easy upgrades
and 'forks' (customers doing their own thing) in exchange for much less surety that the code is running, some performance
trades, a more complex system model (flowing back and forth between JavaScript and Java), and potential for security
holes.  I have seen a number of systems have scripting and the most successful variations have been:</p>

<ul>
<li>Limited scripting to support customizing very controlled situations (e.g. Templating, Workflow, etc.)</li>
<li>Hog-wild scripting that enables customers to 'fork' the code base, where that code base is being run on un-shared servers</li>
</ul>


<p>If you want to have a customizable product, the second approach is definitely very powerful.  Otherwise, the first is probably
safer and simpler.  An example of the benefits to server-side (and ultimately hybrid or 'isomorphic') is described well here:</p>

<ul>
<li> <a href="https://www.youtube.com/watch?v=pgvlHGi9VXM">https://www.youtube.com/watch?v=pgvlHGi9VXM</a></li>
<li> <a href="http://isomorphic.net">http://isomorphic.net</a></li>
</ul>


<h3>What scripting language?</h3>

<p>The obvious modern scripting language to use is JavaScript.  Because of its' pervasiveness in the browser, it is among
the better understood languages out there.  It also has a ridiculously simple and powerful language model (JS is a
(maybe accidental?) descendant of Self, which was an amazingly simple and powerful language too).  And although it does
not have a lot of libraries, running JavaScript via Nashorn enables you to call into the Java world.  A tutorial on
Nashorn is here:</p>

<ul>
<li><a href="http://winterbe.com/posts/2014/04/05/java8-nashorn-tutorial/">http://winterbe.com/posts/2014/04/05/java8-nashorn-tutorial/</a></li>
</ul>


<h2>Summary</h2>

<p>This article described augmenting both the server and the client by putting in three stack
'ingredients' that enable a lot of power (either broadly or in limited situations):</p>

<ul>
<li>Flexible/Semi-structured Data – JSON – On both the client and the server (and the database)</li>
<li>Templating – Dust – On both the client and the server (by the next one)</li>
<li>Scripting: Dual and Isomorphic – JavaScript / Nashorn – Both client and server can then have leverage the same scripting technologies, and potentially chose whether to run something on the server or on the client (or both to enhance SEO)</li>
</ul>


<p>These ingredients make for a much more powerful and flexible application.  These may be overkill for some projects, but
 they are definitely <em>generally useful</em> and whether 'utilized' they should be considered 'available' when needed.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADD Stack [Part-4]]]></title>
    <link href="http://markfussell.emenar.com/blog/addstack-4/"/>
    <updated>2015-10-15T03:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/addstack-4</id>
    <content type="html"><![CDATA[<p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with 'Testing'.  The third with the application stack (Grails and other technologies).</p>

<h2>User Interface</h2>

<p>Of all the technologies that change, the User Interface is by far the most diverse and most evolved.  Modern
databases are actually pretty old technology.  Modern languages are not significantly different from ancestors
in the 1970s.  Computers have the same main components.  Programmers interact with them with keyboards and screens.
If you picked well, you are programming better (tens of thousands of hours help) but are sadly
on pretty much the same core concepts you learned in your first five thousand hours.  Sigh.</p>

<p>Except.  Except the User Interface.  The implementation of user interfaces has grown since the 70s (the
first bit-mapped and mouse-based UIs were built way back then) through Smalltalk, Objective-C, Flash, Flex,
Angular, and other paths.  But even the devices have changed.  An iPhone is not a computer.  An Apple Watch
is not an iPhone.  Times they are a changing... at least for 'devices'.</p>

<h3>It's your face</h3>

<p>The User Interface is also the 'face' of a company.  It sells the company.  Whether to new customers, existing
customers, employees, stock holders, or potential investors.  A web site like Rumble's:</p>

<ul>
<li><a href="http://rumblegames.com/">http://rumblegames.com/</a></li>
</ul>


<p><img src="http://markfussell.emenar.com/images/addstack-4/addstack4_ui1.png" /></p>

<p>And Rumble's actual games are trying to appeal to a particular audience (middle aged men) and give
them something they want (to feel powerful and sophisticated).</p>

<p>A web site like PortaPlanter:</p>

<ul>
<li><a href="http://PortaPlanter.com/">http://PortaPlanter.com/</a></li>
</ul>


<p><img src="http://markfussell.emenar.com/images/addstack-4/addstack4_ui2.png" /></p>

<!--more-->


<p>is targeting a different audience (very broad, green-conscious, etc.) and trying to give them something they want
(to help the planet) where hopefully the product speaks mostly for itself so there are no "frills" on
the page.  The PortaPlanter site is currently a bit under-skinned, but even sophisticated product sites tend to
mostly <em>show the product</em> in isolation and in use.</p>

<p>The expense of the UI should never be under-estimated.  It is <em>by far</em> the most variable expense/investment a company
can control about their software products.  Like marketing.  Build everything <em>perfectly</em> and the UI will be
the only thing that can change the cost.  Well, next to 'rapid feature changes' but that is more controllable
because you can turn it on and off.  The PortaPlanter web site cost a few thousand (mostly the pictures),
is trivial to maintain, and costs nothing to run (static hosting by GitHub).
The Rumble web site cost nearly a million dollars, is made from a very sophisticated PHP package
which costs thousands of dollars to do significant changes to, and hosting it costs thousands of dollars.
That is just the web site of the company, not the games themselves.</p>

<h3>What face do you want?</h3>

<p>The million-dollar Rumble site was primarily done by a company called Viget who came into Rumble and
showed us a bunch of different web sites based on certain aspects we told them we wanted.  The CEO
and his right hand were the primary 'Customers' but we also had a graphic artist that has a great
eye for these things.  Working among the Rumble and Viget teams, we got what you see above.  It is
  implemented in Expression Engine (a PHP engine), but <em>the design</em> and <em>the capabilities</em> are the
  driving factor behind it's cost not the implementation technology (although EE is overkill).</p>

<p>Using a firm like Viget is one approach, but another is to simply figure out what you want to look like.
Jerry Kaplan founded 'Winster' to be an online gambling company.  That was originally illegal, so he
pivoted a bit, but if you look at the site... it looks like Vegas or Reno:</p>

<ul>
<li><a href="http://www.winster.com/">http://www.winster.com/</a></li>
</ul>


<p><img src="http://markfussell.emenar.com/images/addstack-4/addstack4_ui3.png" /></p>

<p>This is exactly what Jerry wanted.  He (the CEO) was the designer and the rest of us just implemented
 his vision (or face his wrath...)</p>

<p>Turns out this web site is somewhat expensive because it was initially built in Flash and Flex (and
when 'converted' Jerry wanted to keep the feel).  So it needs to be quirkier than most web sites
 in spite of its graphic and content simplicity.</p>

<p>For all of my most recent startups, the Face was a huge part:</p>

<ul>
<li>Rumble – Powerful games for powerful people</li>
<li>PeerCase – Modern (iPad caliber), graphically elegant, but intuitive and medical (especially appealing to doctors)</li>
<li>Vive – Must make exercise seem like fun</li>
<li>FooMojo – Make sure virtual pets look as fun as real pets</li>
<li>Winster – Vegas or bust!</li>
</ul>


<p>and each one had a different front-end technology <em>in spite of</em> being written mostly by me and having fairly similar
 back-end technologies (Java, Rails, and Grails).  This isn't because I like swapping out the front-end.  I offered
 to use Flex for all of them.  But Flex isn't mobile.  And the mobile space was of concern to everyone but 'Winster'.</p>

<h3>How do you implement?</h3>

<p>By now you may be groaning:</p>

<blockquote><p>OK. OK. I need to decide what 'face' I want.  I will... I promise...
But what are the choices for implementation?
What is 'plausibly' in the picture as a best implementation approach for the UI.</p></blockquote>

<p>This is pretty easy.  There are simply three productive and effective choices... with some variants within them.</p>

<ul>
<li>Static web site.  By far the most productive and effective if it fills your needs.  You don't write HTML, but the site gets generated from a technology like Markdown.  This site is made that way.</li>
<li>Server-side rendering.  The next most productive and very effective if it fills your needs.  You don't write HTML, you write something like GSPs which are templates that get expanded for each server hit.  The 'petclinic' example is this kind of site.

<ul>
<li>Note this does not mean the client is doing nothing.  It may be doing a lot.  But the server is frequently interacted with to generate pages or partial-pages.</li>
</ul>
</li>
<li>Client-side rendering.  The most sophisticated (sort of) and if this can't fill your need, you can always use either of the above.</li>
</ul>


<p>Some other approaches are 'Native Application' or a 'Native-enhanced web-app' but those need only be considered for very
particular needs.</p>

<p>Among the three main choices, only 'Server' vs. 'Client' lead down interesting paths.  There are lots of 'static' tools so
that is more an experience and 'taste' issue.  Markdown is great, but it isn't for everyone.  And SAAS like SquareSpace
are very nice if they fill your needs.</p>

<h4>Server-side</h4>

<p>The interesting part about server-side rendering is it says <em>nothing</em> about the sophistication of the page.  Or the number
of pages (could be one... could be 1000).  I actually believe that server-side rendering must be considered the default
and then you can decide how much to branch off from there.  PeerCase was mostly a one-page-application (in Sencha) and
most of the client-server interaction was JSON.  But there were different versions of the one-page-application depending
on what kind of client hit the server.  The server bundled up the appropriate resources together and down-they-went.
Desktop clients made a lot a 'asset' requests because they can handle them concurrently and cache them.
Mobile devices got a manifest and did an update in the background.</p>

<p>Grails is great at server-side rendering and can easily use Angular or any framework within each page.</p>

<p>An example of this is the 'angular-grails3' project.  This is just a grails application that includes angular like this:</p>

<p>```html
&lt;!DOCTYPE html>
<html lang="en"></p>

<pre><code>&lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt;
    &lt;title&gt;&lt;g:layoutTitle default="Grails"/&gt;&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;

    &lt;asset:stylesheet src="application.css"/&gt;

    &lt;asset:script type="text/javascript"&gt;
        angular.module('myApp.core.constants')
            .constant('rootUrl', '${grailsApplication.config.angular.rootUrl}')
            .constant('pageSize', '${grailsApplication.config.angular.pageSize}')
            .constant('dateFormat', '${grailsApplication.config.angular.dateFormat}');
    &lt;/asset:script&gt;

    &lt;asset:javascript src="application.js"/&gt;
    &lt;asset:deferredScripts /&gt;
    &lt;g:layoutHead/&gt;
&lt;/head&gt;
&lt;body id="ng-app" ng-app="${pageProperty(name: 'body.ng-app') ?: 'myApp'}"&gt;
</code></pre>

<p>```</p>

<p>and voilà, we have Angular running in a page that can access Grails configuration and application capabilities.</p>

<h4>Client-side</h4>

<p>Client-side rendering is really more like 'separate client from server' development.
It is making "building the client" into somthing
that makes sense independent of the server.  Picking this over server-side rendering is making a few statements:</p>

<ul>
<li>We want to leverage 'separate-client' technology</li>
<li>We may have people who are comfortable with 'separate-client' technology and not with the server technology</li>
<li>We want to increase the chance that we don't do something stupid that prevents us from swapping server or client</li>
</ul>


<p>An example of this approach is the 'grails3-angular-duo' project which has a:</p>

<ul>
<li>backend – In grails</li>
<li>frontend – In Angular + Gulp, Bower, Karma, etc.</li>
</ul>


<p>And although you 'hit the backend' to get your first web page, that actual page comes from
the frontend build system.  And in this case the 'api' is pure REST.</p>

<p>```groovy
class UrlMappings {</p>

<pre><code>static mappings = {
    "/$controller/$action?/$id?(.$format)?"{
        constraints {
            // apply constraints here
        }
    }

    "/"(redirect:"/frontend/index.html")
    "500"(view:'/error')
    "404"(view:'/notFound')

    "/api/books"(resources:"book")
    "/api/authors"(resources:"author")

}
</code></pre>

<p>}
```</p>

<p>Interestingly, the front-end is now a mostly-static web site.  The content isn't static because it depends on JSON,
but most everything else is locked down.  So this is in some ways <em>less</em> flexible than the server side rendering.
Fewer things can change without building another page and sending it out (deploying and referencing it).</p>

<p>```html
&lt;!doctype html>
  <head></p>

<pre><code>&lt;meta charset="utf-8"&gt;
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
&lt;title&gt;&lt;/title&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="viewport" content="width=device-width"&gt;
&lt;link rel="shortcut icon" href="favicon.ico" type="image/x-icon"&gt;
&lt;!-- build:css styles/vendor.css --&gt;
&lt;!-- bower:css --&gt;
&lt;!-- endbower --&gt;
&lt;link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.css" /&gt;
&lt;!-- endbuild --&gt;
&lt;!-- build:css({.tmp,app}) styles/main.css --&gt;
&lt;link rel="stylesheet" href="styles/main.css"&gt;
&lt;!-- endbuild --&gt;
</code></pre>

<p>  </head>
  <body ng-app="duo"></p>

<pre><code>&lt;!--[if lt IE 7]&gt;
  &lt;p class="browsehappy"&gt;You are using an &lt;strong&gt;outdated&lt;/strong&gt; browser. Please &lt;a href="http://browsehappy.com/"&gt;upgrade your browser&lt;/a&gt; to improve your experience.&lt;/p&gt;
&lt;![endif]--&gt;

&lt;div class="header"&gt;
  &lt;ul class="nav nav-pills pull-right"&gt;
    &lt;li class="active"&gt;&lt;a ng-href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a ng-href="#"&gt;About&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a ng-href="#"&gt;Contact&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;h3 class="text-muted"&gt;DUO&lt;/h3&gt;
&lt;/div&gt;

&lt;div class="jumbotron"&gt;
  &lt;h1&gt;Grails Angular Duo Sample&lt;/h1&gt;

&lt;!-- Add your site or application content here --&gt;
&lt;div class="container" ng-view=""&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div class="footer"&gt;
  &lt;p&gt;Using : AngularJS, ngRoute, Restangular&lt;/p&gt;
&lt;/div&gt;

&lt;!-- build:js scripts/vendor.js --&gt;
&lt;!-- bower:js --&gt;
&lt;script src="bower_components/jquery/dist/jquery.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular/angular.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-animate/angular-animate.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-aria/angular-aria.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-cookies/angular-cookies.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-messages/angular-messages.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-route/angular-route.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-sanitize/angular-sanitize.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/angular-touch/angular-touch.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/lodash/lodash.js"&gt;&lt;/script&gt;
&lt;script src="bower_components/restangular/dist/restangular.js"&gt;&lt;/script&gt;
&lt;!-- endbower --&gt;
&lt;!-- endbuild --&gt;

&lt;!-- build:js({.tmp,app}) scripts/scripts.js --&gt;
&lt;script src="scripts/app.js"&gt;&lt;/script&gt;
&lt;script src="scripts/controllers/list-author.js"&gt;&lt;/script&gt;
&lt;script src="scripts/controllers/create-author.js"&gt;&lt;/script&gt;
&lt;script src="scripts/controllers/edit-author.js"&gt;&lt;/script&gt;
&lt;!-- endbuild --&gt;
</code></pre>

<p></body>
</html>
```</p>

<h4>Hybrid</h4>

<p>OK, so I simplified above to get through the main concepts.  Both server-side and separate-client can be
transformed into the most powerful approach known to man... the 'anything goes' or 'hybrid' approach.</p>

<p>Render client, render server, send JSON, receive JSON, send POST, receive POST, open up a direct socket,
send data or HTML both directions, hook into the device's capabilities. take over the camera and capture
 photos of the user, post to twitter, etc.</p>

<p>The problems with Hybrid approaches are:</p>

<ul>
<li>To quantify "What is allowed" and "What is not"</li>
<li>To have a coherent model</li>
<li>To have people understand the model</li>
</ul>


<p>Winster had a very good hybrid model by the time I left (product development had basically ended and Jerry was working solely on Marketing)</p>

<ul>
<li>You hit a Java server</li>
<li>It sends you a Flex application</li>
<li>Most communication is based on JSON calls to the server</li>
<li>But updates to games, chats, and presence come through an open socket</li>
</ul>


<p>The reason for the socket is that you needed to be told of <em>other people's</em> actions.  Some technology (e.g. comet or the socket)
that can "push" updates to the client had to be used for this.  Early on, a previous architect picked sockets, and although the protocol through the socket
improved / evolved, the actual use-of-socket was not swapped out.</p>

<p>Rumble had an extreme hybrid model involving mostly open sockets to game servers,
but also ejabberd (XMPP), JSON, and a slew of different technologies solving different problems.
The drawback of using third-party technologies is that they bring in different approaches to client-server
communication.</p>

<h3>Conclusion</h3>

<p>The goal of the UI is to present a good, cost-effective, consistent, and sufficiently capable 'face' to your
 users and prospects.  There are a number of different approaches that have different benefits.</p>

<p> I recommend
 starting from the position of server-side rendering because that gives a lot of power with almost no extra cost.  It makes people
 work with the entire application and reduces chances of 'schisms' within the development team.  On the
 other hand, 'separate client' technologies are quite good and by thinking 'separate client' you may produce
 a somewhat better API.  But a 'schism' is more likely, testing is harder, and the separate client is
 less flexible in how it can integrate with the server (at least for 'free').</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ADD Stack [Part-3]]]></title>
    <link href="http://markfussell.emenar.com/blog/addstack-3/"/>
    <updated>2015-10-15T02:00:00-07:00</updated>
    <id>http://markfussell.emenar.com/blog/addstack-3</id>
    <content type="html"><![CDATA[<p>This is the second series describing the ADD: a radically more productive development and delivery environment.  The
first article is here: <a href="/blog/addstack-1/">Intro</a> and described the truth and lies about developing software.
The second article dealt with 'Testing'.</p>

<h2>Grails, Groovy, and Java</h2>

<p>The primary stack I believe is a "Best Practice" is Grails.  It is in it's third full generation, and with
each generation it gets better, easier, more powerful, and more 'aligned'.  This last part is not that
common with frameworks.  A lot of people start writing a framework and it does more and more.  With more and more
code.  The Grails team has been great at 'pruning' and 'aligning' with Spring and other frameworks.</p>

<p>Using Spring alone is certainly a reasonable practice.  The problem is people tend to use Spring wrong.  I don't
know why.  Either they don't read the tutorials... or they get confused and a deadline is approaching... or they
are cowboys (or cowgirls) that wander off into new territory of abuse to the tools that are in front of them.
I used Grails at a company that committed to Spring.  So I simply switched to Spring and my code was simple,
functional, well-tested, and clean.  But the rest of the code base was a complete mess.  So there is nothing
wrong with Spring but it is harder to use properly than Grails.  Spring Boot is trying to help with that.  Grails
is just better.</p>

<p>Grails is 'opinionated' and 'functional' and has plenty of examples to show you these opinions and capabilities.
We can see a lot of it in the 'petclinic' example.</p>

<h3>Build with Gradle</h3>

<p>Grails uses Gradle to build the project.  It used to have it's own system, but it pruned that away when Gradle
became stable and capable.  Gradle won a war against other build systems so Grails honored the winner.</p>

<p><img src="http://markfussell.emenar.com/images/addstack-3/addstack3_grails1.png" /></p>

<h3>Align with Spring Boot</h3>

<!--more-->


<p>Spring Boot (<a href="http://projects.spring.io/spring-boot/">http://projects.spring.io/spring-boot/</a>)
is a relatively recent effort to 'default' a lot of the flexibility within Spring.  So Grails
is now leveraging that effort.  Developing with Grails vs. Spring is becoming just a 'small' step up
conceptually so it should be easier for people to 'level up' and also 'wander down' depending on the needs
of the project.</p>

<p><img src="http://markfussell.emenar.com/images/addstack-3/addstack3_grails2.png" /></p>

<h3>Align with Hibernate, but allow others (include NoSQL)</h3>

<p>Grails has always used Hibernate as the primary database mapping system but it is actually capable of mapping
through GORM to other systems.  Some capabilities go away but basic schema and query capability (CRUD)
is always there.  And depending on the product, some higher level query capabilities may also be present.</p>

<h3>Use modern testing frameworks</h3>

<p>As mentioned before: 'geb' and 'spock' are the default testing frameworks included, along with the default
phantomjsdriver and selenium-htmlunit-driver (headless).  This is out-of-the-box, and other testing frameworks
could be used instead or in addition, but there would have to be a compelling reason for it.</p>

<h3>Modern asset pipeline</h3>

<p>Asset management is a big deal for performant websites.  Although the internet is pretty quick, the behavior
of mobile devices is a bit different from (and back a few years from) desktops.  Grails has its own asset
pipeline system that leverages the well-defined layout of a Grails project.</p>

<h3>Good IDE integration</h3>

<p>Grails integrates with IDEA and Eclipse, which are the best (IMO) and most-pervasive (I believe) IDEs
for Java development.</p>

<h3>Plugins!</h3>

<p>Grails has a very simple and powerful plugin system that adds lots of great capabilities.
With the move to 3.x some plugins may not yet be ready, but every month several more should be migrated.</p>

<h3>Standard Layout: assets, controllers, services, views, ...</h3>

<p>Grails has a very clean layout that is mostly aligned with Spring Boot (I believe) and has been mostly
the same over all three generations.  The 'src' directory is for things outside the Grails world.  And
the 'grails-app' directory is for things inside the Grails world.  The grails layout is very intuitive
for a modern web application:</p>

<ul>
<li>assets – Assets to go through the pipeline</li>
<li>conf - Configuration of the application</li>
<li>controllers – The UI (or web-api) interaction layer of the application</li>
<li>domain – The business model layer of the application, and the persistent state model</li>
<li>i18n – Internationalization</li>
<li>init – Things to do at startup</li>
<li>services – One or more 'services' layers to pull logic from controllers and domain into</li>
<li>views – GSP to be used by controllers for rendering (if desired)</li>
</ul>


<p>For the petclinic this layout looks like this when expanded:</p>

<p><img src="http://markfussell.emenar.com/images/addstack-3/addstack3_grails3.png" /></p>

<h3>Modern logging with 'logback'</h3>

<p>Logging is one of the easiest things to swap out, but Grails defaults to the relatively modern 'logback'
<a href="http://logback.qos.ch">http://logback.qos.ch</a> framework.</p>

<p><img src="http://markfussell.emenar.com/images/addstack-3/addstack3_grails4.png" /></p>

<h3>Incredibly terse</h3>

<p>One of the horrors of moving from Smalltalk to Java was about 4-8x the number of words were required to
accomplish the same task.  Writing more is painful.  Painful to write.  Painful to read.  Painful to edit.</p>

<p>With Groovy and Grails, the power of meaning actually leap-frogged both Smalltalk and (amazingly) LISP.
Or at least LISP without a really powerful set of macros.</p>

<p>As an example, the 'PetController' is the main UI functionality of the 'petclinic'.  But it has only 53 lines,
a third of them are blank.  And a total of 150 'words'.</p>

<p>```groovy
package org.grails.samples</p>

<p>class PetController {</p>

<pre><code>def petclinicService

def add() {
    if (request.method == 'GET') {
        return [pet: new Pet(owner: Owner.get(params.owner?.id)), types: PetType.list()]
    }

    def pet = petclinicService.createPet(params.pet_name, params.pet?.birthDate,
        (params.pet?.type?.id ?: 0) as Long, (params.pet_owner_id ?: 0) as Long)

    if (pet.hasErrors()) {
        return [pet: pet, types: PetType.list()]
    }

    redirect controller: 'owner', action: 'show', id: pet.owner.id
}

def edit() {
    if (request.method == 'GET') {
        render view: 'add', model: [pet: Pet.get(params.id), types: PetType.list()]
        return
    }

    def pet = Pet.get(params.id)

    petclinicService.updatePet(pet, params.pet_name, params.pet?.birthDate,
        (params.pet?.type?.id ?: 0) as Long, (params.pet_owner_id ?: 0) as Long)

    if (pet.hasErrors()) {
        render view: 'add', model: [pet: pet, types: PetType.list()]
    }
    else {
        redirect controller: 'owner', action: 'show', id: pet.owner.id
    }
}

def addVisit() {
    if (request.method == 'GET') {
        return [visit: new Visit(pet: Pet.get(params.id))]
    }

    def visit = petclinicService.createVisit((params.visit?.pet?.id ?: 0) as Long, params.visit?.description, params.visit?.date)
    if (visit.hasErrors()) {
        return [visit: visit]
    }

    redirect controller: 'owner', action: 'show', id: visit.pet.owner.id
}
</code></pre>

<p>}
```</p>

<p>It's functionality is not amazing.  But most things people need to do on the web <em>are not amazing</em>.  They are
basically CRUD (Create, Read, Update, Delete).  Include dealing with all kinds of media (documents, images, videos, etc.)
and 99%+ of the web is just doing CRUD.  90%+ is just Read.</p>

<h4>Automatic Wiring</h4>

<p>A lot of things are happening with this controller.  The simple statement</p>

<p><code>groovy
def petclinicService
</code></p>

<p>gets automatically wired to PetclinicService in the services folder.</p>

<h4>Automatic Rendering</h4>

<p>The line</p>

<p>```groovy</p>

<pre><code>        return [pet: new Pet(owner: Owner.get(params.owner?.id)), types: PetType.list()]
</code></pre>

<p>```</p>

<p>causes the view 'pet/add.gsp' to render with that 'pet' and 'types' property set.  So the HTML can also be
quite terse:</p>

<p>```html
<html></p>

<pre><code>&lt;head&gt;
    &lt;meta name="layout" content="main"&gt;
    &lt;title&gt;${ pet.id ? 'Update' : 'Add'} Pet&lt;/title&gt;
&lt;/head&gt;

&lt;body id="add"&gt;
    &lt;h2&gt;&lt;g:if test="${!pet.id}"&gt;New &lt;/g:if&gt;Pet&lt;/h2&gt;

    &lt;b&gt;Owner:&lt;/b&gt; ${pet.owner?.firstName} ${pet.owner?.lastName}
    &lt;br/&gt;
</code></pre>

<p>```</p>

<h4>Powerful redirect and delegation</h4>

<p>Grails can control the client with redirects or delegate to other controllers behind the scenes.</p>

<p>```groovy</p>

<pre><code>    redirect controller: 'owner', action: 'show', id: pet.owner.id
</code></pre>

<p>```</p>

<h4>Very flexibly Services</h4>

<p>The PetclinicService is transactional so it can save objects within an automatic transaction.  But this
is optional and can be controlled.</p>

<p>```groovy
class PetclinicService {</p>

<pre><code>// PetController

Pet createPet(String name, Date birthDate, long petTypeId, long ownerId) {
    def pet = new Pet(name: name, birthDate: birthDate, type: PetType.load(petTypeId), owner: Owner.load(ownerId))
    pet.save()
    pet
}
</code></pre>

<p>```</p>

<h4>Super-clean domain classes</h4>

<p>A modern tendency is to have domain classes mostly represent the data side of the Domain object and pull the
higher level logic out into other classes.  Although I dislike this (why have two classes), it does work
better with automatic schema generation and migration.  You are less likely to have to restart the container
and make the system check for data migration issues.</p>

<p>Grails supports a very simple, rich, mapping system called GORM.  And with it, the Domain class is very terse
but also very powerful.  And GORM works on multiple database <em>kinds</em> let alone products.</p>

<p>```groovy
package org.grails.samples</p>

<p>/<em>*
 * Simple domain object representing a pet.
 *
 * @author Graeme Rocher
 </em>/
class Pet {</p>

<pre><code>String name
Date birthDate
PetType type
Owner owner

static hasMany = [visits: Visit]

static constraints = {
    name blank: false, validator: { name, pet -&gt;
        if (!pet.id &amp;&amp; pet.owner?.pets?.find { it.name == name })  {
            return 'pet.duplicate'
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Apparently Graeme doesn't want people to have duplicate pet names :-/</p>

<h2>Summary</h2>

<p>There is much more functionality to Grails than described above, but that is a good, quick, walk-through.  There
are also certain conventions I believe are best practices on top of the Grails framework (e.g. 'RepoService' classes
for Domain objects so functionality is easily and consistently located), but again that is an augmentation vs. being
a requirement to getting a good picture of the system.</p>

<p>Next I will go into the UI portion and options for that.</p>
]]></content>
  </entry>
  
</feed>
